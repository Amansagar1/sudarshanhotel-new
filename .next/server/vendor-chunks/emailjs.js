"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/emailjs";
exports.ids = ["vendor-chunks/emailjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/emailjs/email.js":
/*!***************************************!*\
  !*** ./node_modules/emailjs/email.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTH_METHODS: () => (/* binding */ AUTH_METHODS),\n/* harmony export */   BUFFERSIZE: () => (/* binding */ BUFFERSIZE),\n/* harmony export */   DEFAULT_TIMEOUT: () => (/* binding */ DEFAULT_TIMEOUT),\n/* harmony export */   MIME64CHUNK: () => (/* binding */ MIME64CHUNK),\n/* harmony export */   MIMECHUNK: () => (/* binding */ MIMECHUNK),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   SMTPClient: () => (/* binding */ SMTPClient),\n/* harmony export */   SMTPConnection: () => (/* binding */ SMTPConnection),\n/* harmony export */   SMTPError: () => (/* binding */ SMTPError),\n/* harmony export */   SMTPErrorStates: () => (/* binding */ SMTPErrorStates),\n/* harmony export */   SMTPResponseMonitor: () => (/* binding */ SMTPResponseMonitor),\n/* harmony export */   SMTPState: () => (/* binding */ SMTPState),\n/* harmony export */   addressparser: () => (/* binding */ addressparser),\n/* harmony export */   getRFC2822Date: () => (/* binding */ getRFC2822Date),\n/* harmony export */   getRFC2822DateUTC: () => (/* binding */ getRFC2822DateUTC),\n/* harmony export */   isRFC2822Date: () => (/* binding */ isRFC2822Date),\n/* harmony export */   mimeEncode: () => (/* binding */ mimeEncode),\n/* harmony export */   mimeWordEncode: () => (/* binding */ mimeWordEncode)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var tls__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tls */ \"tls\");\n\n\n\n\n\n\n\n\n\n/*\n * Operator tokens and which tokens are expected to end the sequence\n */\nconst OPERATORS = new Map([\n    ['\"', '\"'],\n    ['(', ')'],\n    ['<', '>'],\n    [',', ''],\n    // Groups are ended by semicolons\n    [':', ';'],\n    // Semicolons are not a legal delimiter per the RFC2822 grammar other\n    // than for terminating a group, but they are also not valid for any\n    // other use in this context.  Given that some mail clients have\n    // historically allowed the semicolon as a delimiter equivalent to the\n    // comma in their UI, it makes sense to treat them the same as a comma\n    // when used outside of a group.\n    [';', ''],\n]);\n/**\n * Tokenizes the original input string\n *\n * @param {string | string[] | undefined} address string(s) to tokenize\n * @return {AddressToken[]} An array of operator|text tokens\n */\nfunction tokenizeAddress(address = '') {\n    var _a, _b;\n    const tokens = [];\n    let token = undefined;\n    let operator = undefined;\n    for (const character of address.toString()) {\n        if (((_a = operator === null || operator === void 0 ? void 0 : operator.length) !== null && _a !== void 0 ? _a : 0) > 0 && character === operator) {\n            tokens.push({ type: 'operator', value: character });\n            token = undefined;\n            operator = undefined;\n        }\n        else if (((_b = operator === null || operator === void 0 ? void 0 : operator.length) !== null && _b !== void 0 ? _b : 0) === 0 && OPERATORS.has(character)) {\n            tokens.push({ type: 'operator', value: character });\n            token = undefined;\n            operator = OPERATORS.get(character);\n        }\n        else {\n            if (token == null) {\n                token = { type: 'text', value: character };\n                tokens.push(token);\n            }\n            else {\n                token.value += character;\n            }\n        }\n    }\n    return tokens\n        .map((x) => {\n        x.value = x.value.trim();\n        return x;\n    })\n        .filter((x) => x.value.length > 0);\n}\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {AddressToken[]} tokens Tokens object\n * @return {AddressObject[]} addresses object array\n */\nfunction convertAddressTokens(tokens) {\n    const addressObjects = [];\n    const groups = [];\n    let addresses = [];\n    let comments = [];\n    let texts = [];\n    let state = 'text';\n    let isGroup = false;\n    function handleToken(token) {\n        if (token.type === 'operator') {\n            switch (token.value) {\n                case '<':\n                    state = 'address';\n                    break;\n                case '(':\n                    state = 'comment';\n                    break;\n                case ':':\n                    state = 'group';\n                    isGroup = true;\n                    break;\n                default:\n                    state = 'text';\n                    break;\n            }\n        }\n        else if (token.value.length > 0) {\n            switch (state) {\n                case 'address':\n                    addresses.push(token.value);\n                    break;\n                case 'comment':\n                    comments.push(token.value);\n                    break;\n                case 'group':\n                    groups.push(token.value);\n                    break;\n                default:\n                    texts.push(token.value);\n                    break;\n            }\n        }\n    }\n    // Filter out <addresses>, (comments) and regular text\n    for (const token of tokens) {\n        handleToken(token);\n    }\n    // If there is no text but a comment, replace the two\n    if (texts.length === 0 && comments.length > 0) {\n        texts = [...comments];\n        comments = [];\n    }\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    if (isGroup) {\n        addressObjects.push({\n            name: texts.length === 0 ? undefined : texts.join(' '),\n            group: groups.length > 0 ? addressparser(groups.join(',')) : [],\n        });\n    }\n    else {\n        // If no address was found, try to detect one from regular text\n        if (addresses.length === 0 && texts.length > 0) {\n            for (let i = texts.length - 1; i >= 0; i--) {\n                if (texts[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n                    addresses = texts.splice(i, 1);\n                    break;\n                }\n            }\n            // still no address\n            if (addresses.length === 0) {\n                for (let i = texts.length - 1; i >= 0; i--) {\n                    texts[i] = texts[i]\n                        .replace(/\\s*\\b[^@\\s]+@[^@\\s]+\\b\\s*/, (address) => {\n                        if (addresses.length === 0) {\n                            addresses = [address.trim()];\n                            return ' ';\n                        }\n                        else {\n                            return address;\n                        }\n                    })\n                        .trim();\n                    if (addresses.length > 0) {\n                        break;\n                    }\n                }\n            }\n        }\n        // If there's still is no text but a comment exixts, replace the two\n        if (texts.length === 0 && comments.length > 0) {\n            texts = [...comments];\n            comments = [];\n        }\n        // Keep only the first address occurence, push others to regular text\n        if (addresses.length > 1) {\n            texts = [...texts, ...addresses.splice(1)];\n        }\n        if (addresses.length === 0 && isGroup) {\n            return [];\n        }\n        else {\n            // Join values with spaces\n            let address = addresses.join(' ');\n            let name = texts.length === 0 ? address : texts.join(' ');\n            if (address === name) {\n                if (address.match(/@/)) {\n                    name = '';\n                }\n                else {\n                    address = '';\n                }\n            }\n            addressObjects.push({ address, name });\n        }\n    }\n    return addressObjects;\n}\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    \"Name <address@domain>\"\n *\n * will be converted to\n *\n *     [{name: \"Name\", address: \"address@domain\"}]\n *\n * @param {string | string[] | undefined} address Address field\n * @return {AddressObject[]} An array of address objects\n */\nfunction addressparser(address) {\n    const addresses = [];\n    let tokens = [];\n    for (const token of tokenizeAddress(address)) {\n        if (token.type === 'operator' &&\n            (token.value === ',' || token.value === ';')) {\n            if (tokens.length > 0) {\n                addresses.push(...convertAddressTokens(tokens));\n            }\n            tokens = [];\n        }\n        else {\n            tokens.push(token);\n        }\n    }\n    if (tokens.length > 0) {\n        addresses.push(...convertAddressTokens(tokens));\n    }\n    return addresses;\n}\n\n/**\n * @param {Date} [date] an optional date to convert to RFC2822 format\n * @param {boolean} [useUtc] whether to parse the date as UTC (default: false)\n * @returns {string} the converted date\n */\nfunction getRFC2822Date(date = new Date(), useUtc = false) {\n    if (useUtc) {\n        return getRFC2822DateUTC(date);\n    }\n    const dates = date\n        .toString()\n        .replace('GMT', '')\n        .replace(/\\s\\(.*\\)$/, '')\n        .split(' ');\n    dates[0] = dates[0] + ',';\n    const day = dates[1];\n    dates[1] = dates[2];\n    dates[2] = day;\n    return dates.join(' ');\n}\n/**\n * @param {Date} [date] an optional date to convert to RFC2822 format (UTC)\n * @returns {string} the converted date\n */\nfunction getRFC2822DateUTC(date = new Date()) {\n    const dates = date.toUTCString().split(' ');\n    dates.pop(); // remove timezone\n    dates.push('+0000');\n    return dates.join(' ');\n}\n/**\n * RFC 2822 regex\n * @see https://tools.ietf.org/html/rfc2822#section-3.3\n * @see https://github.com/moment/moment/blob/a831fc7e2694281ce31e4f090bbcf90a690f0277/src/lib/create/from-string.js#L101\n */\nconst rfc2822re = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n/**\n * @param {string} [date] a string to check for conformance to the [rfc2822](https://tools.ietf.org/html/rfc2822#section-3.3) standard\n * @returns {boolean} the result of the conformance check\n */\nfunction isRFC2822Date(date) {\n    return rfc2822re.test(date);\n}\n\n// adapted from https://github.com/emailjs/emailjs-mime-codec/blob/6909c706b9f09bc0e5c3faf48f723cca53e5b352/src/mimecodec.js\nconst encoder = new util__WEBPACK_IMPORTED_MODULE_3__.TextEncoder();\n/**\n * @see https://tools.ietf.org/html/rfc2045#section-6.7\n */\nconst RANGES = [\n    [0x09],\n    [0x0a],\n    [0x0d],\n    [0x20, 0x3c],\n    [0x3e, 0x7e], // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n];\nconst LOOKUP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\nconst MAX_CHUNK_LENGTH = 16383; // must be multiple of 3\nconst MAX_MIME_WORD_LENGTH = 52;\nconst MAX_B64_MIME_WORD_BYTE_LENGTH = 39;\nfunction tripletToBase64(num) {\n    return (LOOKUP[(num >> 18) & 0x3f] +\n        LOOKUP[(num >> 12) & 0x3f] +\n        LOOKUP[(num >> 6) & 0x3f] +\n        LOOKUP[num & 0x3f]);\n}\nfunction encodeChunk(uint8, start, end) {\n    let output = '';\n    for (let i = start; i < end; i += 3) {\n        output += tripletToBase64((uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]);\n    }\n    return output;\n}\nfunction encodeBase64(data) {\n    const len = data.length;\n    const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    let output = '';\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (let i = 0, len2 = len - extraBytes; i < len2; i += MAX_CHUNK_LENGTH) {\n        output += encodeChunk(data, i, i + MAX_CHUNK_LENGTH > len2 ? len2 : i + MAX_CHUNK_LENGTH);\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        const tmp = data[len - 1];\n        output += LOOKUP[tmp >> 2];\n        output += LOOKUP[(tmp << 4) & 0x3f];\n        output += '==';\n    }\n    else if (extraBytes === 2) {\n        const tmp = (data[len - 2] << 8) + data[len - 1];\n        output += LOOKUP[tmp >> 10];\n        output += LOOKUP[(tmp >> 4) & 0x3f];\n        output += LOOKUP[(tmp << 2) & 0x3f];\n        output += '=';\n    }\n    return output;\n}\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {string} str Mime encoded string to be split up\n * @param {number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {string[]} lines\n */\nfunction splitMimeEncodedString(str, maxlen = 12) {\n    const minWordLength = 12; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n    const maxWordLength = Math.max(maxlen, minWordLength);\n    const lines = [];\n    while (str.length) {\n        let curLine = str.substr(0, maxWordLength);\n        const match = curLine.match(/=[0-9A-F]?$/i); // skip incomplete escaped char\n        if (match) {\n            curLine = curLine.substr(0, match.index);\n        }\n        let done = false;\n        while (!done) {\n            let chr;\n            done = true;\n            const match = str.substr(curLine.length).match(/^=([0-9A-F]{2})/i); // check if not middle of a unicode char sequence\n            if (match) {\n                chr = parseInt(match[1], 16);\n                // invalid sequence, move one char back anc recheck\n                if (chr < 0xc2 && chr > 0x7f) {\n                    curLine = curLine.substr(0, curLine.length - 3);\n                    done = false;\n                }\n            }\n        }\n        if (curLine.length) {\n            lines.push(curLine);\n        }\n        str = str.substr(curLine.length);\n    }\n    return lines;\n}\n/**\n *\n * @param {number} nr number\n * @returns {boolean} if number is in range\n */\nfunction checkRanges(nr) {\n    return RANGES.reduce((val, range) => val ||\n        (range.length === 1 && nr === range[0]) ||\n        (range.length === 2 && nr >= range[0] && nr <= range[1]), false);\n}\n/**\n * Encodes all non printable and non ascii bytes to =XX form, where XX is the\n * byte value in hex. This function does not convert linebreaks etc. it\n * only escapes character sequences\n *\n * NOTE: Encoding support depends on util.TextDecoder, which is severely limited\n * prior to Node.js 13.\n *\n * @see https://nodejs.org/api/util.html#util_whatwg_supported_encodings\n * @see https://github.com/nodejs/node/issues/19214\n *\n * @param {string|Uint8Array} data Either a string or an Uint8Array\n * @param {string} encoding WHATWG supported encoding\n * @return {string} Mime encoded string\n */\nfunction mimeEncode(data = '', encoding = 'utf-8') {\n    const decoder = new util__WEBPACK_IMPORTED_MODULE_3__.TextDecoder(encoding);\n    const buffer = typeof data === 'string'\n        ? encoder.encode(data)\n        : encoder.encode(decoder.decode(data));\n    return buffer.reduce((aggregate, ord, index) => checkRanges(ord) &&\n        !((ord === 0x20 || ord === 0x09) &&\n            (index === buffer.length - 1 ||\n                buffer[index + 1] === 0x0a ||\n                buffer[index + 1] === 0x0d))\n        ? // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n            aggregate + String.fromCharCode(ord)\n        : `${aggregate}=${ord < 0x10 ? '0' : ''}${ord\n            .toString(16)\n            .toUpperCase()}`, '');\n}\n/**\n * Encodes a string or an Uint8Array to an UTF-8 MIME Word\n *\n * NOTE: Encoding support depends on util.TextDecoder, which is severely limited\n * prior to Node.js 13.\n *\n * @see https://tools.ietf.org/html/rfc2047\n * @see https://nodejs.org/api/util.html#util_whatwg_supported_encodings\n * @see https://github.com/nodejs/node/issues/19214\n *\n * @param {string|Uint8Array} data String to be encoded\n * @param {'Q' | 'B'} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {string} encoding WHATWG supported encoding\n * @return {string} Single or several mime words joined together\n */\nfunction mimeWordEncode(data, mimeWordEncoding = 'Q', encoding = 'utf-8') {\n    let parts = [];\n    const decoder = new util__WEBPACK_IMPORTED_MODULE_3__.TextDecoder(encoding);\n    const str = typeof data === 'string' ? data : decoder.decode(data);\n    if (mimeWordEncoding === 'Q') {\n        const encodedStr = mimeEncode(str, encoding).replace(/[^a-z0-9!*+\\-/=]/gi, (chr) => chr === ' '\n            ? '_'\n            : '=' +\n                (chr.charCodeAt(0) < 0x10 ? '0' : '') +\n                chr.charCodeAt(0).toString(16).toUpperCase());\n        parts =\n            encodedStr.length < MAX_MIME_WORD_LENGTH\n                ? [encodedStr]\n                : splitMimeEncodedString(encodedStr, MAX_MIME_WORD_LENGTH);\n    }\n    else {\n        // Fits as much as possible into every line without breaking utf-8 multibyte characters' octets up across lines\n        let j = 0;\n        let i = 0;\n        while (i < str.length) {\n            if (encoder.encode(str.substring(j, i)).length >\n                MAX_B64_MIME_WORD_BYTE_LENGTH) {\n                // we went one character too far, substring at the char before\n                parts.push(str.substring(j, i - 1));\n                j = i - 1;\n            }\n            else {\n                i++;\n            }\n        }\n        // add the remainder of the string\n        str.substring(j) && parts.push(str.substring(j));\n        parts = parts.map((x) => encoder.encode(x)).map((x) => encodeBase64(x));\n    }\n    return parts\n        .map((p) => `=?UTF-8?${mimeWordEncoding}?${p}?= `)\n        .join('')\n        .trim();\n}\n\nconst CRLF$1 = '\\r\\n';\n/**\n * MIME standard wants 76 char chunks when sending out.\n */\nconst MIMECHUNK = 76;\n/**\n * meets both base64 and mime divisibility\n */\nconst MIME64CHUNK = (MIMECHUNK * 6);\n/**\n * size of the message stream buffer\n */\nconst BUFFERSIZE = (MIMECHUNK * 24 * 7);\nlet counter = 0;\nfunction generateBoundary() {\n    let text = '';\n    const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'()+_,-./:=?\";\n    for (let i = 0; i < 69; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n}\nfunction convertPersonToAddress(person) {\n    return addressparser(person)\n        .map(({ name, address }) => {\n        return name\n            ? `${mimeWordEncode(name).replace(/,/g, '=2C')} <${address}>`\n            : address;\n    })\n        .join(', ');\n}\nfunction convertDashDelimitedTextToSnakeCase(text) {\n    return text\n        .toLowerCase()\n        .replace(/^(.)|-(.)/g, (match) => match.toUpperCase());\n}\nclass Message {\n    /**\n     * Construct an rfc2822-compliant message object.\n     *\n     * Special notes:\n     * - The `from` field is required.\n     * - At least one `to`, `cc`, or `bcc` header is also required.\n     * - You can also add whatever other headers you want.\n     *\n     * @see https://tools.ietf.org/html/rfc2822\n     * @param {Partial<MessageHeaders>} headers Message headers\n     */\n    constructor(headers) {\n        this.attachments = [];\n        this.header = {\n            'message-id': `<${new Date().getTime()}.${counter++}.${process.pid}@${(0,os__WEBPACK_IMPORTED_MODULE_1__.hostname)()}>`,\n            date: getRFC2822Date(),\n        };\n        this.content = 'text/plain; charset=utf-8';\n        this.alternative = null;\n        for (const header in headers) {\n            // allow user to override default content-type to override charset or send a single non-text message\n            if (/^content-type$/i.test(header)) {\n                this.content = headers[header];\n            }\n            else if (header === 'text') {\n                this.text = headers[header];\n            }\n            else if (header === 'attachment' &&\n                typeof headers[header] === 'object') {\n                const attachment = headers[header];\n                if (Array.isArray(attachment)) {\n                    for (let i = 0; i < attachment.length; i++) {\n                        this.attach(attachment[i]);\n                    }\n                }\n                else if (attachment != null) {\n                    this.attach(attachment);\n                }\n            }\n            else if (header === 'subject') {\n                this.header.subject = mimeWordEncode(headers.subject);\n            }\n            else if (/^(cc|bcc|to|from)/i.test(header)) {\n                this.header[header.toLowerCase()] = convertPersonToAddress(headers[header]);\n            }\n            else {\n                // allow any headers the user wants to set??\n                this.header[header.toLowerCase()] = headers[header];\n            }\n        }\n    }\n    /**\n     * Attach a file to the message.\n     *\n     * Can be called multiple times, each adding a new attachment.\n     *\n     * @public\n     * @param {MessageAttachment} options attachment options\n     * @returns {Message} the current instance for chaining\n     */\n    attach(options) {\n        // sender can specify an attachment as an alternative\n        if (options.alternative) {\n            this.alternative = options;\n            this.alternative.charset = options.charset || 'utf-8';\n            this.alternative.type = options.type || 'text/html';\n            this.alternative.inline = true;\n        }\n        else {\n            this.attachments.push(options);\n        }\n        return this;\n    }\n    /**\n     * @public\n     * @returns {{ isValid: boolean, validationError: (string | undefined) }} an object specifying whether this message is validly formatted, and the first validation error if it is not.\n     */\n    checkValidity() {\n        if (typeof this.header.from !== 'string' &&\n            Array.isArray(this.header.from) === false) {\n            return {\n                isValid: false,\n                validationError: 'Message must have a `from` header',\n            };\n        }\n        if (typeof this.header.to !== 'string' &&\n            Array.isArray(this.header.to) === false &&\n            typeof this.header.cc !== 'string' &&\n            Array.isArray(this.header.cc) === false &&\n            typeof this.header.bcc !== 'string' &&\n            Array.isArray(this.header.bcc) === false) {\n            return {\n                isValid: false,\n                validationError: 'Message must have at least one `to`, `cc`, or `bcc` header',\n            };\n        }\n        if (this.attachments.length > 0) {\n            const failed = [];\n            this.attachments.forEach((attachment) => {\n                if (attachment.path) {\n                    if ((0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(attachment.path) === false) {\n                        failed.push(`${attachment.path} does not exist`);\n                    }\n                }\n                else if (attachment.stream) {\n                    if (!attachment.stream.readable) {\n                        failed.push('attachment stream is not readable');\n                    }\n                }\n                else if (!attachment.data) {\n                    failed.push('attachment has no data associated with it');\n                }\n            });\n            return {\n                isValid: failed.length === 0,\n                validationError: failed.join(', '),\n            };\n        }\n        return { isValid: true, validationError: undefined };\n    }\n    /**\n     * @public\n     * @deprecated does not conform to the `errback` style followed by the rest of the library, and will be removed in the next major version. use `checkValidity` instead.\n     * @param {function(isValid: boolean, invalidReason: (string | undefined)): void} callback .\n     * @returns {void}\n     */\n    valid(callback) {\n        const { isValid, validationError } = this.checkValidity();\n        callback(isValid, validationError);\n    }\n    /**\n     * @public\n     * @returns {MessageStream} a stream of the current message\n     */\n    stream() {\n        return new MessageStream(this);\n    }\n    /**\n     * @public\n     * @param {function(Error, string): void} callback the function to call with the error and buffer\n     * @returns {void}\n     */\n    read(callback) {\n        let buffer = '';\n        const str = this.stream();\n        str.on('data', (data) => (buffer += data));\n        str.on('end', (err) => callback(err, buffer));\n        str.on('error', (err) => callback(err, buffer));\n    }\n    readAsync() {\n        return new Promise((resolve, reject) => {\n            this.read((err, buffer) => {\n                if (err != null) {\n                    reject(err);\n                }\n                else {\n                    resolve(buffer);\n                }\n            });\n        });\n    }\n}\nclass MessageStream extends stream__WEBPACK_IMPORTED_MODULE_2__.Stream {\n    /**\n     * @param {Message} message the message to stream\n     */\n    constructor(message) {\n        super();\n        this.message = message;\n        this.readable = true;\n        this.paused = false;\n        this.buffer = Buffer.alloc(MIMECHUNK * 24 * 7);\n        this.bufferIndex = 0;\n        /**\n         * @param {string} [data] the data to output\n         * @param {Function} [callback] the function\n         * @param {any[]} [args] array of arguments to pass to the callback\n         * @returns {void}\n         */\n        const output = (data) => {\n            // can we buffer the data?\n            if (this.buffer != null) {\n                const bytes = Buffer.byteLength(data);\n                if (bytes + this.bufferIndex < this.buffer.length) {\n                    this.buffer.write(data, this.bufferIndex);\n                    this.bufferIndex += bytes;\n                }\n                // we can't buffer the data, so ship it out!\n                else if (bytes > this.buffer.length) {\n                    if (this.bufferIndex) {\n                        this.emit('data', this.buffer.toString('utf-8', 0, this.bufferIndex));\n                        this.bufferIndex = 0;\n                    }\n                    const loops = Math.ceil(data.length / this.buffer.length);\n                    let loop = 0;\n                    while (loop < loops) {\n                        this.emit('data', data.substring(this.buffer.length * loop, this.buffer.length * (loop + 1)));\n                        loop++;\n                    }\n                } // we need to clean out the buffer, it is getting full\n                else {\n                    if (!this.paused) {\n                        this.emit('data', this.buffer.toString('utf-8', 0, this.bufferIndex));\n                        this.buffer.write(data, 0);\n                        this.bufferIndex = bytes;\n                    }\n                    else {\n                        // we can't empty out the buffer, so let's wait till we resume before adding to it\n                        this.once('resume', () => output(data));\n                    }\n                }\n            }\n        };\n        /**\n         * @param {MessageAttachment} [attachment] the attachment whose headers you would like to output\n         * @returns {void}\n         */\n        const outputAttachmentHeaders = (attachment) => {\n            let data = [];\n            const headers = {\n                'content-type': attachment.type +\n                    (attachment.charset ? `; charset=${attachment.charset}` : '') +\n                    (attachment.method ? `; method=${attachment.method}` : ''),\n                'content-transfer-encoding': 'base64',\n                'content-disposition': attachment.inline\n                    ? 'inline'\n                    : `attachment; filename=\"${mimeWordEncode(attachment.name)}\"`,\n            };\n            // allow sender to override default headers\n            if (attachment.headers != null) {\n                for (const header in attachment.headers) {\n                    headers[header.toLowerCase()] = attachment.headers[header];\n                }\n            }\n            for (const header in headers) {\n                data = data.concat([\n                    convertDashDelimitedTextToSnakeCase(header),\n                    ': ',\n                    headers[header],\n                    CRLF$1,\n                ]);\n            }\n            output(data.concat([CRLF$1]).join(''));\n        };\n        /**\n         * @param {string} data the data to output as base64\n         * @param {function(): void} [callback] the function to call after output is finished\n         * @returns {void}\n         */\n        const outputBase64 = (data, callback) => {\n            const loops = Math.ceil(data.length / MIMECHUNK);\n            let loop = 0;\n            while (loop < loops) {\n                output(data.substring(MIMECHUNK * loop, MIMECHUNK * (loop + 1)) + CRLF$1);\n                loop++;\n            }\n            if (callback) {\n                callback();\n            }\n        };\n        const outputFile = (attachment, next) => {\n            var _a;\n            const chunk = MIME64CHUNK * 16;\n            const buffer = Buffer.alloc(chunk);\n            const inputEncoding = ((_a = attachment === null || attachment === void 0 ? void 0 : attachment.headers) === null || _a === void 0 ? void 0 : _a['content-transfer-encoding']) || 'base64';\n            const encoding = inputEncoding === '7bit'\n                ? 'ascii'\n                : inputEncoding === '8bit'\n                    ? 'binary'\n                    : inputEncoding;\n            /**\n             * @param {Error} err the error to emit\n             * @param {number} fd the file descriptor\n             * @returns {void}\n             */\n            const opened = (err, fd) => {\n                if (err) {\n                    this.emit('error', err);\n                    return;\n                }\n                const readBytes = (err, bytes) => {\n                    if (err || this.readable === false) {\n                        this.emit('error', err || new Error('message stream was interrupted somehow!'));\n                        return;\n                    }\n                    // guaranteed to be encoded without padding unless it is our last read\n                    outputBase64(buffer.toString(encoding, 0, bytes), () => {\n                        if (bytes == chunk) {\n                            // we read a full chunk, there might be more\n                            (0,fs__WEBPACK_IMPORTED_MODULE_0__.read)(fd, buffer, 0, chunk, null, readBytes);\n                        } // that was the last chunk, we are done reading the file\n                        else {\n                            this.removeListener('error', fs__WEBPACK_IMPORTED_MODULE_0__.closeSync);\n                            (0,fs__WEBPACK_IMPORTED_MODULE_0__.close)(fd, next);\n                        }\n                    });\n                };\n                (0,fs__WEBPACK_IMPORTED_MODULE_0__.read)(fd, buffer, 0, chunk, null, readBytes);\n                this.once('error', fs__WEBPACK_IMPORTED_MODULE_0__.closeSync);\n            };\n            (0,fs__WEBPACK_IMPORTED_MODULE_0__.open)(attachment.path, 'r', opened);\n        };\n        /**\n         * @param {MessageAttachment} attachment the metadata to use as headers\n         * @param {function(): void} callback the function to call after output is finished\n         * @returns {void}\n         */\n        const outputStream = (attachment, callback) => {\n            const { stream } = attachment;\n            if (stream === null || stream === void 0 ? void 0 : stream.readable) {\n                let previous = Buffer.alloc(0);\n                stream.resume();\n                stream.on('end', () => {\n                    outputBase64(previous.toString('base64'), callback);\n                    this.removeListener('pause', stream.pause);\n                    this.removeListener('resume', stream.resume);\n                    this.removeListener('error', stream.resume);\n                });\n                stream.on('data', (buff) => {\n                    // do we have bytes from a previous stream data event?\n                    let buffer = Buffer.isBuffer(buff) ? buff : Buffer.from(buff);\n                    if (previous.byteLength > 0) {\n                        buffer = Buffer.concat([previous, buffer]);\n                    }\n                    const padded = buffer.length % MIME64CHUNK;\n                    previous = Buffer.alloc(padded);\n                    // encode as much of the buffer to base64 without empty bytes\n                    if (padded > 0) {\n                        // copy dangling bytes into previous buffer\n                        buffer.copy(previous, 0, buffer.length - padded);\n                    }\n                    outputBase64(buffer.toString('base64', 0, buffer.length - padded));\n                });\n                this.on('pause', stream.pause);\n                this.on('resume', stream.resume);\n                this.on('error', stream.resume);\n            }\n            else {\n                this.emit('error', { message: 'stream not readable' });\n            }\n        };\n        const outputAttachment = (attachment, callback) => {\n            const build = attachment.path\n                ? outputFile\n                : attachment.stream\n                    ? outputStream\n                    : outputData;\n            outputAttachmentHeaders(attachment);\n            build(attachment, callback);\n        };\n        /**\n         * @param {string} boundary the boundary text between outputs\n         * @param {MessageAttachment[]} list the list of potential messages to output\n         * @param {number} index the index of the list item to output\n         * @param {function(): void} callback the function to call if index is greater than upper bound\n         * @returns {void}\n         */\n        const outputMessage = (boundary, list, index, callback) => {\n            if (index < list.length) {\n                output(`--${boundary}${CRLF$1}`);\n                if (list[index].related) {\n                    outputRelated(list[index], () => outputMessage(boundary, list, index + 1, callback));\n                }\n                else {\n                    outputAttachment(list[index], () => outputMessage(boundary, list, index + 1, callback));\n                }\n            }\n            else {\n                output(`${CRLF$1}--${boundary}--${CRLF$1}${CRLF$1}`);\n                callback();\n            }\n        };\n        const outputMixed = () => {\n            const boundary = generateBoundary();\n            output(`Content-Type: multipart/mixed; boundary=\"${boundary}\"${CRLF$1}${CRLF$1}--${boundary}${CRLF$1}`);\n            if (this.message.alternative == null) {\n                outputText(this.message);\n                outputMessage(boundary, this.message.attachments, 0, close$1);\n            }\n            else {\n                outputAlternative(\n                // typescript bug; should narrow to { alternative: MessageAttachment }\n                this.message, () => outputMessage(boundary, this.message.attachments, 0, close$1));\n            }\n        };\n        /**\n         * @param {MessageAttachment} attachment the metadata to use as headers\n         * @param {function(): void} callback the function to call after output is finished\n         * @returns {void}\n         */\n        const outputData = (attachment, callback) => {\n            var _a, _b;\n            outputBase64(attachment.encoded\n                ? (_a = attachment.data) !== null && _a !== void 0 ? _a : ''\n                : Buffer.from((_b = attachment.data) !== null && _b !== void 0 ? _b : '').toString('base64'), callback);\n        };\n        /**\n         * @param {Message} message the message to output\n         * @returns {void}\n         */\n        const outputText = (message) => {\n            let data = [];\n            data = data.concat([\n                'Content-Type:',\n                message.content,\n                CRLF$1,\n                'Content-Transfer-Encoding: 7bit',\n                CRLF$1,\n            ]);\n            data = data.concat(['Content-Disposition: inline', CRLF$1, CRLF$1]);\n            data = data.concat([message.text || '', CRLF$1, CRLF$1]);\n            output(data.join(''));\n        };\n        /**\n         * @param {MessageAttachment} message the message to output\n         * @param {function(): void} callback the function to call after output is finished\n         * @returns {void}\n         */\n        const outputRelated = (message, callback) => {\n            const boundary = generateBoundary();\n            output(`Content-Type: multipart/related; boundary=\"${boundary}\"${CRLF$1}${CRLF$1}--${boundary}${CRLF$1}`);\n            outputAttachment(message, () => {\n                var _a;\n                outputMessage(boundary, (_a = message.related) !== null && _a !== void 0 ? _a : [], 0, () => {\n                    output(`${CRLF$1}--${boundary}--${CRLF$1}${CRLF$1}`);\n                    callback();\n                });\n            });\n        };\n        /**\n         * @param {Message} message the message to output\n         * @param {function(): void} callback the function to call after output is finished\n         * @returns {void}\n         */\n        const outputAlternative = (message, callback) => {\n            const boundary = generateBoundary();\n            output(`Content-Type: multipart/alternative; boundary=\"${boundary}\"${CRLF$1}${CRLF$1}--${boundary}${CRLF$1}`);\n            outputText(message);\n            output(`--${boundary}${CRLF$1}`);\n            /**\n             * @returns {void}\n             */\n            const finish = () => {\n                output([CRLF$1, '--', boundary, '--', CRLF$1, CRLF$1].join(''));\n                callback();\n            };\n            if (message.alternative.related) {\n                outputRelated(message.alternative, finish);\n            }\n            else {\n                outputAttachment(message.alternative, finish);\n            }\n        };\n        const close$1 = (err) => {\n            var _a, _b;\n            if (err) {\n                this.emit('error', err);\n            }\n            else {\n                this.emit('data', (_b = (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.toString('utf-8', 0, this.bufferIndex)) !== null && _b !== void 0 ? _b : '');\n                this.emit('end');\n            }\n            this.buffer = null;\n            this.bufferIndex = 0;\n            this.readable = false;\n            this.removeAllListeners('resume');\n            this.removeAllListeners('pause');\n            this.removeAllListeners('error');\n            this.removeAllListeners('data');\n            this.removeAllListeners('end');\n        };\n        /**\n         * @returns {void}\n         */\n        const outputHeaderData = () => {\n            if (this.message.attachments.length || this.message.alternative) {\n                output(`MIME-Version: 1.0${CRLF$1}`);\n                outputMixed();\n            } // you only have a text message!\n            else {\n                outputText(this.message);\n                close$1();\n            }\n        };\n        /**\n         * @returns {void}\n         */\n        const outputHeader = () => {\n            let data = [];\n            for (const header in this.message.header) {\n                // do not output BCC in the headers (regex) nor custom Object.prototype functions...\n                if (!/bcc/i.test(header) &&\n                    Object.prototype.hasOwnProperty.call(this.message.header, header)) {\n                    data = data.concat([\n                        convertDashDelimitedTextToSnakeCase(header),\n                        ': ',\n                        this.message.header[header],\n                        CRLF$1,\n                    ]);\n                }\n            }\n            output(data.join(''));\n            outputHeaderData();\n        };\n        this.once('destroy', close$1);\n        process.nextTick(outputHeader);\n    }\n    /**\n     * @public\n     * pause the stream\n     * @returns {void}\n     */\n    pause() {\n        this.paused = true;\n        this.emit('pause');\n    }\n    /**\n     * @public\n     * resume the stream\n     * @returns {void}\n     */\n    resume() {\n        this.paused = false;\n        this.emit('resume');\n    }\n    /**\n     * @public\n     * destroy the stream\n     * @returns {void}\n     */\n    destroy() {\n        this.emit('destroy', this.bufferIndex > 0 ? { message: 'message stream destroyed' } : null);\n    }\n    /**\n     * @public\n     * destroy the stream at first opportunity\n     * @returns {void}\n     */\n    destroySoon() {\n        this.emit('destroy');\n    }\n}\n\n/**\n * @readonly\n * @enum\n */\nconst SMTPErrorStates = {\n    COULDNOTCONNECT: 1,\n    BADRESPONSE: 2,\n    AUTHFAILED: 3,\n    TIMEDOUT: 4,\n    ERROR: 5,\n    NOCONNECTION: 6,\n    AUTHNOTSUPPORTED: 7,\n    CONNECTIONCLOSED: 8,\n    CONNECTIONENDED: 9,\n    CONNECTIONAUTH: 10,\n};\nclass SMTPError extends Error {\n    /**\n     * @protected\n     * @param {string} message error message\n     */\n    constructor(message) {\n        super(message);\n        this.code = null;\n        this.smtp = null;\n        this.previous = null;\n    }\n    /**\n     *\n     * @param {string} message error message\n     * @param {number} code smtp error state\n     * @param {Error | null} error previous error\n     * @param {unknown} smtp arbitrary data\n     * @returns {SMTPError} error\n     */\n    static create(message, code, error, smtp) {\n        const msg = (error === null || error === void 0 ? void 0 : error.message) ? `${message} (${error.message})` : message;\n        const err = new SMTPError(msg);\n        err.code = code;\n        err.smtp = smtp;\n        if (error) {\n            err.previous = error;\n        }\n        return err;\n    }\n}\n\nclass SMTPResponseMonitor {\n    constructor(stream, timeout, onerror) {\n        let buffer = '';\n        const notify = () => {\n            var _a, _b;\n            if (buffer.length) {\n                // parse buffer for response codes\n                const line = buffer.replace('\\r', '');\n                if (!((_b = (_a = line\n                    .trim()\n                    .split(/\\n/)\n                    .pop()) === null || _a === void 0 ? void 0 : _a.match(/^(\\d{3})\\s/)) !== null && _b !== void 0 ? _b : false)) {\n                    return;\n                }\n                const match = line ? line.match(/(\\d+)\\s?(.*)/) : null;\n                const data = match !== null\n                    ? { code: match[1], message: match[2], data: line }\n                    : { code: -1, data: line };\n                stream.emit('response', null, data);\n                buffer = '';\n            }\n        };\n        const error = (err) => {\n            stream.emit('response', SMTPError.create('connection encountered an error', SMTPErrorStates.ERROR, err));\n        };\n        const timedout = (err) => {\n            stream.end();\n            stream.emit('response', SMTPError.create('timedout while connecting to smtp server', SMTPErrorStates.TIMEDOUT, err));\n        };\n        const watch = (data) => {\n            if (data !== null) {\n                buffer += data.toString();\n                notify();\n            }\n        };\n        const close = (err) => {\n            stream.emit('response', SMTPError.create('connection has closed', SMTPErrorStates.CONNECTIONCLOSED, err));\n        };\n        const end = (err) => {\n            stream.emit('response', SMTPError.create('connection has ended', SMTPErrorStates.CONNECTIONENDED, err));\n        };\n        this.stop = (err) => {\n            stream.removeAllListeners('response');\n            stream.removeListener('data', watch);\n            stream.removeListener('end', end);\n            stream.removeListener('close', close);\n            stream.removeListener('error', error);\n            if (err != null && typeof onerror === 'function') {\n                onerror(err);\n            }\n        };\n        stream.on('data', watch);\n        stream.on('end', end);\n        stream.on('close', close);\n        stream.on('error', error);\n        stream.setTimeout(timeout, timedout);\n    }\n}\n\n/**\n * @readonly\n * @enum\n */\nconst AUTH_METHODS = {\n    PLAIN: 'PLAIN',\n    'CRAM-MD5': 'CRAM-MD5',\n    LOGIN: 'LOGIN',\n    XOAUTH2: 'XOAUTH2',\n};\n/**\n * @readonly\n * @enum\n */\nconst SMTPState = {\n    NOTCONNECTED: 0,\n    CONNECTING: 1,\n    CONNECTED: 2,\n};\nconst DEFAULT_TIMEOUT = 5000;\nconst SMTP_PORT = 25;\nconst SMTP_SSL_PORT = 465;\nconst SMTP_TLS_PORT = 587;\nconst CRLF = '\\r\\n';\nconst GREYLIST_DELAY = 300;\nlet DEBUG = 0;\n/**\n * @param {...any[]} args the message(s) to log\n * @returns {void}\n */\nconst log = (...args) => {\n    if (DEBUG === 1) {\n        args.forEach((d) => console.log(typeof d === 'object'\n            ? d instanceof Error\n                ? d.message\n                : JSON.stringify(d)\n            : d));\n    }\n};\n/**\n * @param {function(...any[]): void} callback the function to call\n * @param {...any[]} args the arguments to apply to the function\n * @returns {void}\n */\nconst caller = (callback, ...args) => {\n    if (typeof callback === 'function') {\n        callback(...args);\n    }\n};\nclass SMTPConnection extends events__WEBPACK_IMPORTED_MODULE_5__.EventEmitter {\n    /**\n     * SMTP class written using python's (2.7) smtplib.py as a base.\n     *\n     * To target a Message Transfer Agent (MTA), omit all options.\n     *\n     * NOTE: `host` is trimmed before being used to establish a connection; however, the original untrimmed value will still be visible in configuration.\n     */\n    constructor({ timeout, host, user, password, domain, port, ssl, tls, logger, authentication, } = {}) {\n        var _a;\n        super();\n        this.timeout = DEFAULT_TIMEOUT;\n        this.log = log;\n        this.authentication = [\n            AUTH_METHODS['CRAM-MD5'],\n            AUTH_METHODS.LOGIN,\n            AUTH_METHODS.PLAIN,\n            AUTH_METHODS.XOAUTH2,\n        ];\n        this._state = SMTPState.NOTCONNECTED;\n        this._secure = false;\n        this.loggedin = false;\n        this.sock = null;\n        this.features = null;\n        this.monitor = null;\n        this.domain = (0,os__WEBPACK_IMPORTED_MODULE_1__.hostname)();\n        this.host = 'localhost';\n        this.ssl = false;\n        this.tls = false;\n        this.greylistResponseTracker = new WeakSet();\n        if (Array.isArray(authentication)) {\n            this.authentication = authentication;\n        }\n        if (typeof timeout === 'number') {\n            this.timeout = timeout;\n        }\n        if (typeof domain === 'string') {\n            this.domain = domain;\n        }\n        if (typeof host === 'string') {\n            this.host = host;\n        }\n        if (ssl != null &&\n            (typeof ssl === 'boolean' ||\n                (typeof ssl === 'object' && Array.isArray(ssl) === false))) {\n            this.ssl = ssl;\n        }\n        if (tls != null &&\n            (typeof tls === 'boolean' ||\n                (typeof tls === 'object' && Array.isArray(tls) === false))) {\n            this.tls = tls;\n        }\n        this.port = port || (ssl ? SMTP_SSL_PORT : tls ? SMTP_TLS_PORT : SMTP_PORT);\n        this.loggedin = user && password ? false : true;\n        if (!user && ((_a = password === null || password === void 0 ? void 0 : password.length) !== null && _a !== void 0 ? _a : 0) > 0) {\n            throw new Error('`password` cannot be set without `user`');\n        }\n        // keep these strings hidden when quicky debugging/logging\n        this.user = () => user;\n        this.password = () => password;\n        if (typeof logger === 'function') {\n            this.log = logger;\n        }\n    }\n    /**\n     * @public\n     * @param {0 | 1} level -\n     * @returns {void}\n     */\n    debug(level) {\n        DEBUG = level;\n    }\n    /**\n     * @public\n     * @returns {SMTPState} the current state\n     */\n    state() {\n        return this._state;\n    }\n    /**\n     * @public\n     * @returns {boolean} whether or not the instance is authorized\n     */\n    authorized() {\n        return this.loggedin;\n    }\n    /**\n     * Establish an SMTP connection.\n     *\n     * NOTE: `host` is trimmed before being used to establish a connection; however, the original untrimmed value will still be visible in configuration.\n     *\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {number} [port] the port to use for the connection\n     * @param {string} [host] the hostname to use for the connection\n     * @param {ConnectOptions} [options={}] the options\n     * @returns {void}\n     */\n    connect(callback, port = this.port, host = this.host, options = {}) {\n        this.port = port;\n        this.host = host;\n        this.ssl = options.ssl || this.ssl;\n        if (this._state !== SMTPState.NOTCONNECTED) {\n            this.quit(() => this.connect(callback, port, host, options));\n        }\n        /**\n         * @returns {void}\n         */\n        const connected = () => {\n            this.log(`connected: ${this.host}:${this.port}`);\n            if (this.ssl && !this.tls) {\n                // if key/ca/cert was passed in, check if connection is authorized\n                if (typeof this.ssl !== 'boolean' &&\n                    this.sock instanceof tls__WEBPACK_IMPORTED_MODULE_7__.TLSSocket &&\n                    !this.sock.authorized) {\n                    this.close(true);\n                    caller(callback, SMTPError.create('could not establish an ssl connection', SMTPErrorStates.CONNECTIONAUTH));\n                }\n                else {\n                    this._secure = true;\n                }\n            }\n        };\n        /**\n         * @param {Error} err err\n         * @returns {void}\n         */\n        const connectedErrBack = (err) => {\n            if (!err) {\n                connected();\n            }\n            else {\n                this.close(true);\n                this.log(err);\n                caller(callback, SMTPError.create('could not connect', SMTPErrorStates.COULDNOTCONNECT, err));\n            }\n        };\n        const response = (err, msg) => {\n            if (err) {\n                if (this._state === SMTPState.NOTCONNECTED && !this.sock) {\n                    return;\n                }\n                this.close(true);\n                caller(callback, err);\n            }\n            else if (msg.code == '220') {\n                this.log(msg.data);\n                // might happen first, so no need to wait on connected()\n                this._state = SMTPState.CONNECTED;\n                caller(callback, null, msg.data);\n            }\n            else {\n                this.log(`response (data): ${msg.data}`);\n                this.quit(() => {\n                    caller(callback, SMTPError.create('bad response on connection', SMTPErrorStates.BADRESPONSE, err, msg.data));\n                });\n            }\n        };\n        this._state = SMTPState.CONNECTING;\n        this.log(`connecting: ${this.host}:${this.port}`);\n        if (this.ssl) {\n            this.sock = (0,tls__WEBPACK_IMPORTED_MODULE_7__.connect)(this.port, this.host.trim(), typeof this.ssl === 'object' ? this.ssl : {}, connected);\n        }\n        else {\n            this.sock = new net__WEBPACK_IMPORTED_MODULE_6__.Socket();\n            this.sock.connect(this.port, this.host.trim(), connectedErrBack);\n        }\n        this.monitor = new SMTPResponseMonitor(this.sock, this.timeout, () => this.close(true));\n        this.sock.once('response', response);\n        this.sock.once('error', response); // the socket could reset or throw, so let's handle it and let the user know\n    }\n    /**\n     * @public\n     * @param {string} str the string to send\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    send(str, callback) {\n        if (this.sock != null && this._state === SMTPState.CONNECTED) {\n            this.log(str);\n            this.sock.once('response', (err, msg) => {\n                if (err) {\n                    caller(callback, err);\n                }\n                else {\n                    this.log(msg.data);\n                    caller(callback, null, msg);\n                }\n            });\n            if (this.sock.writable) {\n                this.sock.write(str);\n            }\n        }\n        else {\n            this.close(true);\n            caller(callback, SMTPError.create('no connection has been established', SMTPErrorStates.NOCONNECTION));\n        }\n    }\n    /**\n     * @public\n     * @param {string} cmd command to issue\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {(number[] | number)} [codes=[250]] array codes\n     * @returns {void}\n     */\n    command(cmd, callback, codes = [250]) {\n        const codesArray = Array.isArray(codes)\n            ? codes\n            : typeof codes === 'number'\n                ? [codes]\n                : [250];\n        const response = (err, msg) => {\n            if (err) {\n                caller(callback, err);\n            }\n            else {\n                const code = Number(msg.code);\n                if (codesArray.indexOf(code) !== -1) {\n                    caller(callback, err, msg.data, msg.message);\n                }\n                else if ((code === 450 || code === 451) &&\n                    msg.message.toLowerCase().includes('greylist') &&\n                    this.greylistResponseTracker.has(response) === false) {\n                    this.greylistResponseTracker.add(response);\n                    setTimeout(() => {\n                        this.send(cmd + CRLF, response);\n                    }, GREYLIST_DELAY);\n                }\n                else {\n                    const suffix = msg.message ? `: ${msg.message}` : '';\n                    const errorMessage = `bad response on command '${cmd.split(' ')[0]}'${suffix}`;\n                    caller(callback, SMTPError.create(errorMessage, SMTPErrorStates.BADRESPONSE, null, msg.data));\n                }\n            }\n        };\n        this.greylistResponseTracker.delete(response);\n        this.send(cmd + CRLF, response);\n    }\n    /**\n     * @public\n     * @description SMTP 'helo' command.\n     *\n     * Hostname to send for self command defaults to the FQDN of the local\n     * host.\n     *\n     * As this command was deprecated by rfc2821, it should only be used for compatibility with non-compliant servers.\n     * @see https://tools.ietf.org/html/rfc2821#appendix-F.3\n     *\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} domain the domain to associate with the 'helo' request\n     * @returns {void}\n     */\n    helo(callback, domain) {\n        this.command(`helo ${domain || this.domain}`, (err, data) => {\n            if (err) {\n                caller(callback, err);\n            }\n            else {\n                this.parse_smtp_features(data);\n                caller(callback, err, data);\n            }\n        });\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    starttls(callback) {\n        const response = (err, msg) => {\n            if (this.sock == null) {\n                throw new Error('null socket');\n            }\n            if (err) {\n                err.message += ' while establishing a starttls session';\n                caller(callback, err);\n            }\n            else {\n                const secureContext = (0,tls__WEBPACK_IMPORTED_MODULE_7__.createSecureContext)(typeof this.tls === 'object' ? this.tls : {});\n                const secureSocket = new tls__WEBPACK_IMPORTED_MODULE_7__.TLSSocket(this.sock, { secureContext });\n                secureSocket.on('error', (err) => {\n                    this.close(true);\n                    caller(callback, err);\n                });\n                this._secure = true;\n                this.sock = secureSocket;\n                new SMTPResponseMonitor(this.sock, this.timeout, () => this.close(true));\n                caller(callback, msg.data);\n            }\n        };\n        this.command('starttls', response, [220]);\n    }\n    /**\n     * @public\n     * @param {string} data the string to parse for features\n     * @returns {void}\n     */\n    parse_smtp_features(data) {\n        //  According to RFC1869 some (badly written)\n        //  MTA's will disconnect on an ehlo. Toss an exception if\n        //  that happens -ddm\n        data.split('\\n').forEach((ext) => {\n            const parse = ext.match(/^(?:\\d+[-=]?)\\s*?([^\\s]+)(?:\\s+(.*)\\s*?)?$/);\n            // To be able to communicate with as many SMTP servers as possible,\n            // we have to take the old-style auth advertisement into account,\n            // because:\n            // 1) Else our SMTP feature parser gets confused.\n            // 2) There are some servers that only advertise the auth methods we\n            // support using the old style.\n            if (parse != null && this.features != null) {\n                // RFC 1869 requires a space between ehlo keyword and parameters.\n                // It's actually stricter, in that only spaces are allowed between\n                // parameters, but were not going to check for that here.  Note\n                // that the space isn't present if there are no parameters.\n                this.features[parse[1].toLowerCase()] = parse[2] || true;\n            }\n        });\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} domain the domain to associate with the 'ehlo' request\n     * @returns {void}\n     */\n    ehlo(callback, domain) {\n        this.features = {};\n        this.command(`ehlo ${domain || this.domain}`, (err, data) => {\n            if (err) {\n                caller(callback, err);\n            }\n            else {\n                this.parse_smtp_features(data);\n                if (this.tls && !this._secure) {\n                    this.starttls(() => this.ehlo(callback, domain));\n                }\n                else {\n                    caller(callback, err, data);\n                }\n            }\n        });\n    }\n    /**\n     * @public\n     * @param {string} opt the features keyname to check\n     * @returns {boolean} whether the extension exists\n     */\n    has_extn(opt) {\n        var _a;\n        return ((_a = this.features) !== null && _a !== void 0 ? _a : {})[opt.toLowerCase()] === undefined;\n    }\n    /**\n     * @public\n     * @description SMTP 'help' command, returns text from the server\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} domain the domain to associate with the 'help' request\n     * @returns {void}\n     */\n    help(callback, domain) {\n        this.command(domain ? `help ${domain}` : 'help', callback, [211, 214]);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    rset(callback) {\n        this.command('rset', callback);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    noop(callback) {\n        this.send('noop', callback);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} from the sender\n     * @returns {void}\n     */\n    mail(callback, from) {\n        this.command(`mail FROM:${from}`, callback);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} to the receiver\n     * @returns {void}\n     */\n    rcpt(callback, to) {\n        this.command(`RCPT TO:${to}`, callback, [250, 251]);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    data(callback) {\n        this.command('data', callback, [354]);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    data_end(callback) {\n        this.command(`${CRLF}.`, callback);\n    }\n    /**\n     * @public\n     * @param {string} data the message to send\n     * @returns {void}\n     */\n    message(data) {\n        var _a, _b;\n        this.log(data);\n        (_b = (_a = this.sock) === null || _a === void 0 ? void 0 : _a.write(data)) !== null && _b !== void 0 ? _b : this.log('no socket to write to');\n    }\n    /**\n     * @public\n     * @description SMTP 'verify' command -- checks for address validity.\n     * @param {string} address the address to validate\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    verify(address, callback) {\n        this.command(`vrfy ${address}`, callback, [250, 251, 252]);\n    }\n    /**\n     * @public\n     * @description SMTP 'expn' command -- expands a mailing list.\n     * @param {string} address the mailing list to expand\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    expn(address, callback) {\n        this.command(`expn ${address}`, callback);\n    }\n    /**\n     * @public\n     * @description Calls this.ehlo() and, if an error occurs, this.helo().\n     *\n     * If there has been no previous EHLO or HELO command self session, self\n     * method tries ESMTP EHLO first.\n     *\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} [domain] the domain to associate with the command\n     * @returns {void}\n     */\n    ehlo_or_helo_if_needed(callback, domain) {\n        // is this code callable...?\n        if (!this.features) {\n            const response = (err, data) => caller(callback, err, data);\n            this.ehlo((err, data) => {\n                if (err) {\n                    this.helo(response, domain);\n                }\n                else {\n                    caller(callback, err, data);\n                }\n            }, domain);\n        }\n    }\n    /**\n     * @public\n     *\n     * Log in on an SMTP server that requires authentication.\n     *\n     * If there has been no previous EHLO or HELO command self session, self\n     * method tries ESMTP EHLO first.\n     *\n     * This method will return normally if the authentication was successful.\n     *\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} [user] the username to authenticate with\n     * @param {string} [password] the password for the authentication\n     * @param {{ method: string, domain: string }} [options] login options\n     * @returns {void}\n     */\n    login(callback, user, password, options = {}) {\n        var _a, _b;\n        const login = {\n            user: user ? () => user : this.user,\n            password: password ? () => password : this.password,\n            method: (_b = (_a = options === null || options === void 0 ? void 0 : options.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : '',\n        };\n        const domain = (options === null || options === void 0 ? void 0 : options.domain) || this.domain;\n        const initiate = (err, data) => {\n            var _a;\n            if (err) {\n                caller(callback, err);\n                return;\n            }\n            let method = null;\n            /**\n             * @param {string} challenge challenge\n             * @returns {string} base64 cram hash\n             */\n            const encodeCramMd5 = (challenge) => {\n                const hmac = (0,crypto__WEBPACK_IMPORTED_MODULE_4__.createHmac)('md5', login.password());\n                hmac.update(Buffer.from(challenge, 'base64').toString('ascii'));\n                return Buffer.from(`${login.user()} ${hmac.digest('hex')}`).toString('base64');\n            };\n            /**\n             * @returns {string} base64 login/password\n             */\n            const encodePlain = () => Buffer.from(`\\u0000${login.user()}\\u0000${login.password()}`).toString('base64');\n            /**\n             * @see https://developers.google.com/gmail/xoauth2_protocol\n             * @returns {string} base64 xoauth2 auth token\n             */\n            const encodeXoauth2 = () => Buffer.from(`user=${login.user()}\\u0001auth=Bearer ${login.password()}\\u0001\\u0001`).toString('base64');\n            // List of authentication methods we support: from preferred to\n            // less preferred methods.\n            if (!method) {\n                const preferred = this.authentication;\n                let auth = '';\n                if (typeof ((_a = this.features) === null || _a === void 0 ? void 0 : _a['auth']) === 'string') {\n                    auth = this.features['auth'];\n                }\n                for (let i = 0; i < preferred.length; i++) {\n                    if (auth.includes(preferred[i])) {\n                        method = preferred[i];\n                        break;\n                    }\n                }\n            }\n            /**\n             * handle bad responses from command differently\n             * @param {Error} err err\n             * @param {unknown} data data\n             * @returns {void}\n             */\n            const failed = (err, data) => {\n                this.loggedin = false;\n                this.close(); // if auth is bad, close the connection, it won't get better by itself\n                err.message = err.message.replace(this.password(), 'REDACTED');\n                caller(callback, SMTPError.create('authorization.failed', SMTPErrorStates.AUTHFAILED, err, data));\n            };\n            /**\n             * @param {Error} err err\n             * @param {unknown} data data\n             * @returns {void}\n             */\n            const response = (err, data) => {\n                if (err) {\n                    failed(err, data);\n                }\n                else {\n                    this.loggedin = true;\n                    caller(callback, err, data);\n                }\n            };\n            /**\n             * @param {Error} err err\n             * @param {unknown} data data\n             * @param {string} msg msg\n             * @returns {void}\n             */\n            const attempt = (err, data, msg) => {\n                if (err) {\n                    failed(err, data);\n                }\n                else {\n                    if (method === AUTH_METHODS['CRAM-MD5']) {\n                        this.command(encodeCramMd5(msg), response, [235, 503]);\n                    }\n                    else if (method === AUTH_METHODS.LOGIN) {\n                        this.command(Buffer.from(login.password()).toString('base64'), response, [235, 503]);\n                    }\n                }\n            };\n            /**\n             * @param {Error} err err\n             * @param {unknown} data data\n             * @param {string} msg msg\n             * @returns {void}\n             */\n            const attemptUser = (err, data) => {\n                if (err) {\n                    failed(err, data);\n                }\n                else {\n                    if (method === AUTH_METHODS.LOGIN) {\n                        this.command(Buffer.from(login.user()).toString('base64'), attempt, [334]);\n                    }\n                }\n            };\n            switch (method) {\n                case AUTH_METHODS['CRAM-MD5']:\n                    this.command(`AUTH  ${AUTH_METHODS['CRAM-MD5']}`, attempt, [334]);\n                    break;\n                case AUTH_METHODS.LOGIN:\n                    this.command(`AUTH ${AUTH_METHODS.LOGIN}`, attemptUser, [334]);\n                    break;\n                case AUTH_METHODS.PLAIN:\n                    this.command(`AUTH ${AUTH_METHODS.PLAIN} ${encodePlain()}`, response, [235, 503]);\n                    break;\n                case AUTH_METHODS.XOAUTH2:\n                    this.command(`AUTH ${AUTH_METHODS.XOAUTH2} ${encodeXoauth2()}`, response, [235, 503]);\n                    break;\n                default:\n                    caller(callback, SMTPError.create('no form of authorization supported', SMTPErrorStates.AUTHNOTSUPPORTED, null, data));\n                    break;\n            }\n        };\n        this.ehlo_or_helo_if_needed(initiate, domain);\n    }\n    /**\n     * @public\n     * @param {boolean} [force=false] whether or not to force destroy the connection\n     * @returns {void}\n     */\n    close(force = false) {\n        if (this.sock) {\n            if (force) {\n                this.log('smtp connection destroyed!');\n                this.sock.destroy();\n            }\n            else {\n                this.log('smtp connection closed.');\n                this.sock.end();\n            }\n        }\n        if (this.monitor) {\n            this.monitor.stop();\n            this.monitor = null;\n        }\n        this._state = SMTPState.NOTCONNECTED;\n        this._secure = false;\n        this.sock = null;\n        this.features = null;\n        this.loggedin = !(this.user() && this.password());\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} [callback] function to call after response\n     * @returns {void}\n     */\n    quit(callback) {\n        this.command('quit', (err, data) => {\n            caller(callback, err, data);\n            this.close();\n        }, [221, 250]);\n    }\n}\n\nclass SMTPClient {\n    /**\n     * Create a standard SMTP client backed by a self-managed SMTP connection.\n     *\n     * NOTE: `host` is trimmed before being used to establish a connection; however, the original untrimmed value will still be visible in configuration.\n     *\n     * @param {SMTPConnectionOptions} server smtp options\n     */\n    constructor(server) {\n        this.queue = [];\n        this.sending = false;\n        this.ready = false;\n        this.timer = null;\n        this.smtp = new SMTPConnection(server);\n    }\n    /**\n     * @public\n     * @template {Message | MessageHeaders} T\n     * @param {T} msg the message to send\n     * @param {MessageCallback<T>} callback receiver for the error (if any) as well as the passed-in message / headers\n     * @returns {void}\n     */\n    send(msg, callback) {\n        const message = msg instanceof Message\n            ? msg\n            : this._canMakeMessage(msg)\n                ? new Message(msg)\n                : null;\n        if (message == null) {\n            callback(new Error('message is not a valid Message instance'), msg);\n            return;\n        }\n        const { isValid, validationError } = message.checkValidity();\n        if (isValid) {\n            const stack = this.createMessageStack(message, callback);\n            if (stack.to.length === 0) {\n                return callback(new Error('No recipients found in message'), msg);\n            }\n            this.queue.push(stack);\n            this._poll();\n        }\n        else {\n            callback(new Error(validationError), msg);\n        }\n    }\n    /**\n     * @public\n     * @template {Message | MessageHeaders} T\n     * @param {T} msg the message to send\n     * @returns {Promise<T>} a promise that resolves to the passed-in message / headers\n     */\n    sendAsync(msg) {\n        return new Promise((resolve, reject) => {\n            this.send(msg, (err, message) => {\n                if (err != null) {\n                    reject(err);\n                }\n                else {\n                    // unfortunately, the conditional type doesn't reach here\n                    // fortunately, we only return a `Message` when err is null, so this is safe\n                    resolve(message);\n                }\n            });\n        });\n    }\n    /**\n     * @public\n     * @description Converts a message to the raw object used by the internal stack.\n     * @param {Message} message message to convert\n     * @param {MessageCallback} callback errback\n     * @returns {MessageStack} raw message object\n     */\n    createMessageStack(message, callback = function () {\n        /*  */\n    }) {\n        const [{ address: from }] = addressparser(message.header.from);\n        const stack = {\n            message,\n            to: [],\n            from,\n            callback: callback.bind(this),\n        };\n        const { header: { to, cc, bcc, 'return-path': returnPath }, } = message;\n        if ((typeof to === 'string' || Array.isArray(to)) && to.length > 0) {\n            stack.to = addressparser(to);\n        }\n        if ((typeof cc === 'string' || Array.isArray(cc)) && cc.length > 0) {\n            stack.to = stack.to.concat(addressparser(cc).filter((x) => stack.to.some((y) => y.address === x.address) === false));\n        }\n        if ((typeof bcc === 'string' || Array.isArray(bcc)) && bcc.length > 0) {\n            stack.to = stack.to.concat(addressparser(bcc).filter((x) => stack.to.some((y) => y.address === x.address) === false));\n        }\n        if (typeof returnPath === 'string' && returnPath.length > 0) {\n            const parsedReturnPath = addressparser(returnPath);\n            if (parsedReturnPath.length > 0) {\n                const [{ address: returnPathAddress }] = parsedReturnPath;\n                stack.returnPath = returnPathAddress;\n            }\n        }\n        return stack;\n    }\n    /**\n     * @protected\n     * @returns {void}\n     */\n    _poll() {\n        if (this.timer != null) {\n            clearTimeout(this.timer);\n        }\n        if (this.queue.length) {\n            if (this.smtp.state() == SMTPState.NOTCONNECTED) {\n                this._connect(this.queue[0]);\n            }\n            else if (this.smtp.state() == SMTPState.CONNECTED &&\n                !this.sending &&\n                this.ready) {\n                this._sendmail(this.queue.shift());\n            }\n        }\n        // wait around 1 seconds in case something does come in,\n        // otherwise close out SMTP connection if still open\n        else if (this.smtp.state() == SMTPState.CONNECTED) {\n            this.timer = setTimeout(() => this.smtp.quit(), 1000);\n        }\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _connect(stack) {\n        /**\n         * @param {Error} err callback error\n         * @returns {void}\n         */\n        const connect = (err) => {\n            if (!err) {\n                const begin = (err) => {\n                    if (!err) {\n                        this.ready = true;\n                        this._poll();\n                    }\n                    else {\n                        stack.callback(err, stack.message);\n                        // clear out the queue so all callbacks can be called with the same error message\n                        this.queue.shift();\n                        this._poll();\n                    }\n                };\n                if (!this.smtp.authorized()) {\n                    this.smtp.login(begin);\n                }\n                else {\n                    this.smtp.ehlo_or_helo_if_needed(begin);\n                }\n            }\n            else {\n                stack.callback(err, stack.message);\n                // clear out the queue so all callbacks can be called with the same error message\n                this.queue.shift();\n                this._poll();\n            }\n        };\n        this.ready = false;\n        this.smtp.connect(connect);\n    }\n    /**\n     * @protected\n     * @param {MessageStack} msg message stack\n     * @returns {boolean} can make message\n     */\n    _canMakeMessage(msg) {\n        return (msg.from &&\n            (msg.to || msg.cc || msg.bcc) &&\n            (msg.text !== undefined || this._containsInlinedHtml(msg.attachment)));\n    }\n    /**\n     * @protected\n     * @param {MessageAttachment | MessageAttachment[]} attachment attachment\n     * @returns {boolean} whether the attachment contains inlined html\n     */\n    _containsInlinedHtml(attachment) {\n        if (Array.isArray(attachment)) {\n            return attachment.some((att) => {\n                return this._isAttachmentInlinedHtml(att);\n            });\n        }\n        else {\n            return this._isAttachmentInlinedHtml(attachment);\n        }\n    }\n    /**\n     * @protected\n     * @param {MessageAttachment} attachment attachment\n     * @returns {boolean} whether the attachment is inlined html\n     */\n    _isAttachmentInlinedHtml(attachment) {\n        return (attachment &&\n            (attachment.data || attachment.path) &&\n            attachment.alternative === true);\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @param {function(MessageStack): void} next next\n     * @returns {function(Error): void} callback\n     */\n    _sendsmtp(stack, next) {\n        /**\n         * @param {Error} [err] error\n         * @returns {void}\n         */\n        return (err) => {\n            if (!err && next) {\n                next.apply(this, [stack]);\n            }\n            else {\n                // if we snag on SMTP commands, call done, passing the error\n                // but first reset SMTP state so queue can continue polling\n                this.smtp.rset(() => this._senddone(err, stack));\n            }\n        };\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _sendmail(stack) {\n        const from = stack.returnPath || stack.from;\n        this.sending = true;\n        this.smtp.mail(this._sendsmtp(stack, this._sendrcpt), '<' + from + '>');\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _sendrcpt(stack) {\n        var _a;\n        if (stack.to == null || typeof stack.to === 'string') {\n            throw new TypeError('stack.to must be array');\n        }\n        const to = (_a = stack.to.shift()) === null || _a === void 0 ? void 0 : _a.address;\n        this.smtp.rcpt(this._sendsmtp(stack, stack.to.length ? this._sendrcpt : this._senddata), `<${to}>`);\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _senddata(stack) {\n        this.smtp.data(this._sendsmtp(stack, this._sendmessage));\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _sendmessage(stack) {\n        const stream = stack.message.stream();\n        stream.on('data', (data) => this.smtp.message(data));\n        stream.on('end', () => {\n            this.smtp.data_end(this._sendsmtp(stack, () => this._senddone(null, stack)));\n        });\n        // there is no way to cancel a message while in the DATA portion,\n        // so we have to close the socket to prevent a bad email from going out\n        stream.on('error', (err) => {\n            this.smtp.close();\n            this._senddone(err, stack);\n        });\n    }\n    /**\n     * @protected\n     * @param {Error} err err\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _senddone(err, stack) {\n        this.sending = false;\n        stack.callback(err, stack.message);\n        this._poll();\n    }\n}\n\n\n//# sourceMappingURL=email.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQzdCLGVBQWUsOEJBQThCO0FBQzdDLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLEdBQUc7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyUTtBQUMzUSIsInNvdXJjZXMiOlsiRDpcXHByaXZhdGUgd29ya1xcc3VkYXJzaGFuaG90ZWwtbmV3XFxub2RlX21vZHVsZXNcXGVtYWlsanNcXGVtYWlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0c1N5bmMsIG9wZW4sIHJlYWQsIGNsb3NlU3luYywgY2xvc2UgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBob3N0bmFtZSB9IGZyb20gJ29zJztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgeyBUZXh0RW5jb2RlciwgVGV4dERlY29kZXIgfSBmcm9tICd1dGlsJztcbmltcG9ydCB7IGNyZWF0ZUhtYWMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IFNvY2tldCB9IGZyb20gJ25ldCc7XG5pbXBvcnQgeyBjb25uZWN0LCBUTFNTb2NrZXQsIGNyZWF0ZVNlY3VyZUNvbnRleHQgfSBmcm9tICd0bHMnO1xuXG4vKlxuICogT3BlcmF0b3IgdG9rZW5zIGFuZCB3aGljaCB0b2tlbnMgYXJlIGV4cGVjdGVkIHRvIGVuZCB0aGUgc2VxdWVuY2VcbiAqL1xuY29uc3QgT1BFUkFUT1JTID0gbmV3IE1hcChbXG4gICAgWydcIicsICdcIiddLFxuICAgIFsnKCcsICcpJ10sXG4gICAgWyc8JywgJz4nXSxcbiAgICBbJywnLCAnJ10sXG4gICAgLy8gR3JvdXBzIGFyZSBlbmRlZCBieSBzZW1pY29sb25zXG4gICAgWyc6JywgJzsnXSxcbiAgICAvLyBTZW1pY29sb25zIGFyZSBub3QgYSBsZWdhbCBkZWxpbWl0ZXIgcGVyIHRoZSBSRkMyODIyIGdyYW1tYXIgb3RoZXJcbiAgICAvLyB0aGFuIGZvciB0ZXJtaW5hdGluZyBhIGdyb3VwLCBidXQgdGhleSBhcmUgYWxzbyBub3QgdmFsaWQgZm9yIGFueVxuICAgIC8vIG90aGVyIHVzZSBpbiB0aGlzIGNvbnRleHQuICBHaXZlbiB0aGF0IHNvbWUgbWFpbCBjbGllbnRzIGhhdmVcbiAgICAvLyBoaXN0b3JpY2FsbHkgYWxsb3dlZCB0aGUgc2VtaWNvbG9uIGFzIGEgZGVsaW1pdGVyIGVxdWl2YWxlbnQgdG8gdGhlXG4gICAgLy8gY29tbWEgaW4gdGhlaXIgVUksIGl0IG1ha2VzIHNlbnNlIHRvIHRyZWF0IHRoZW0gdGhlIHNhbWUgYXMgYSBjb21tYVxuICAgIC8vIHdoZW4gdXNlZCBvdXRzaWRlIG9mIGEgZ3JvdXAuXG4gICAgWyc7JywgJyddLFxuXSk7XG4vKipcbiAqIFRva2VuaXplcyB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZH0gYWRkcmVzcyBzdHJpbmcocykgdG8gdG9rZW5pemVcbiAqIEByZXR1cm4ge0FkZHJlc3NUb2tlbltdfSBBbiBhcnJheSBvZiBvcGVyYXRvcnx0ZXh0IHRva2Vuc1xuICovXG5mdW5jdGlvbiB0b2tlbml6ZUFkZHJlc3MoYWRkcmVzcyA9ICcnKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgbGV0IG9wZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgY2hhcmFjdGVyIG9mIGFkZHJlc3MudG9TdHJpbmcoKSkge1xuICAgICAgICBpZiAoKChfYSA9IG9wZXJhdG9yID09PSBudWxsIHx8IG9wZXJhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVyYXRvci5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApID4gMCAmJiBjaGFyYWN0ZXIgPT09IG9wZXJhdG9yKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiBjaGFyYWN0ZXIgfSk7XG4gICAgICAgICAgICB0b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2IgPSBvcGVyYXRvciA9PT0gbnVsbCB8fCBvcGVyYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BlcmF0b3IubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSA9PT0gMCAmJiBPUEVSQVRPUlMuaGFzKGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ29wZXJhdG9yJywgdmFsdWU6IGNoYXJhY3RlciB9KTtcbiAgICAgICAgICAgIHRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgb3BlcmF0b3IgPSBPUEVSQVRPUlMuZ2V0KGNoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0geyB0eXBlOiAndGV4dCcsIHZhbHVlOiBjaGFyYWN0ZXIgfTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSArPSBjaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vuc1xuICAgICAgICAubWFwKCh4KSA9PiB7XG4gICAgICAgIHgudmFsdWUgPSB4LnZhbHVlLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcigoeCkgPT4geC52YWx1ZS5sZW5ndGggPiAwKTtcbn1cbi8qKlxuICogQ29udmVydHMgdG9rZW5zIGZvciBhIHNpbmdsZSBhZGRyZXNzIGludG8gYW4gYWRkcmVzcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0FkZHJlc3NUb2tlbltdfSB0b2tlbnMgVG9rZW5zIG9iamVjdFxuICogQHJldHVybiB7QWRkcmVzc09iamVjdFtdfSBhZGRyZXNzZXMgb2JqZWN0IGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRBZGRyZXNzVG9rZW5zKHRva2Vucykge1xuICAgIGNvbnN0IGFkZHJlc3NPYmplY3RzID0gW107XG4gICAgY29uc3QgZ3JvdXBzID0gW107XG4gICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgIGxldCBjb21tZW50cyA9IFtdO1xuICAgIGxldCB0ZXh0cyA9IFtdO1xuICAgIGxldCBzdGF0ZSA9ICd0ZXh0JztcbiAgICBsZXQgaXNHcm91cCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVRva2VuKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2FkZHJlc3MnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAnY29tbWVudCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9ICdncm91cCc7XG4gICAgICAgICAgICAgICAgICAgIGlzR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9ICd0ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaCh0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZ3JvdXAnOlxuICAgICAgICAgICAgICAgICAgICBncm91cHMucHVzaCh0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRleHRzLnB1c2godG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaWx0ZXIgb3V0IDxhZGRyZXNzZXM+LCAoY29tbWVudHMpIGFuZCByZWd1bGFyIHRleHRcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICBoYW5kbGVUb2tlbih0b2tlbik7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHRleHQgYnV0IGEgY29tbWVudCwgcmVwbGFjZSB0aGUgdHdvXG4gICAgaWYgKHRleHRzLmxlbmd0aCA9PT0gMCAmJiBjb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRleHRzID0gWy4uLmNvbW1lbnRzXTtcbiAgICAgICAgY29tbWVudHMgPSBbXTtcbiAgICB9XG4gICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNhcHBlbmRpeC1BLjEuM1xuICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgIGFkZHJlc3NPYmplY3RzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogdGV4dHMubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogdGV4dHMuam9pbignICcpLFxuICAgICAgICAgICAgZ3JvdXA6IGdyb3Vwcy5sZW5ndGggPiAwID8gYWRkcmVzc3BhcnNlcihncm91cHMuam9pbignLCcpKSA6IFtdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIG5vIGFkZHJlc3Mgd2FzIGZvdW5kLCB0cnkgdG8gZGV0ZWN0IG9uZSBmcm9tIHJlZ3VsYXIgdGV4dFxuICAgICAgICBpZiAoYWRkcmVzc2VzLmxlbmd0aCA9PT0gMCAmJiB0ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGV4dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dHNbaV0ubWF0Y2goL15bXkBcXHNdK0BbXkBcXHNdKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMgPSB0ZXh0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0aWxsIG5vIGFkZHJlc3NcbiAgICAgICAgICAgIGlmIChhZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRleHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRzW2ldID0gdGV4dHNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqXFxiW15AXFxzXStAW15AXFxzXStcXGJcXHMqLywgKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzID0gW2FkZHJlc3MudHJpbSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgc3RpbGwgaXMgbm8gdGV4dCBidXQgYSBjb21tZW50IGV4aXh0cywgcmVwbGFjZSB0aGUgdHdvXG4gICAgICAgIGlmICh0ZXh0cy5sZW5ndGggPT09IDAgJiYgY29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGV4dHMgPSBbLi4uY29tbWVudHNdO1xuICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBLZWVwIG9ubHkgdGhlIGZpcnN0IGFkZHJlc3Mgb2NjdXJlbmNlLCBwdXNoIG90aGVycyB0byByZWd1bGFyIHRleHRcbiAgICAgICAgaWYgKGFkZHJlc3Nlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0ZXh0cyA9IFsuLi50ZXh0cywgLi4uYWRkcmVzc2VzLnNwbGljZSgxKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3Nlcy5sZW5ndGggPT09IDAgJiYgaXNHcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSm9pbiB2YWx1ZXMgd2l0aCBzcGFjZXNcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gYWRkcmVzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIGxldCBuYW1lID0gdGV4dHMubGVuZ3RoID09PSAwID8gYWRkcmVzcyA6IHRleHRzLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MubWF0Y2goL0AvKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkcmVzc09iamVjdHMucHVzaCh7IGFkZHJlc3MsIG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3NPYmplY3RzO1xufVxuLyoqXG4gKiBQYXJzZXMgc3RydWN0dXJlZCBlLW1haWwgYWRkcmVzc2VzIGZyb20gYW4gYWRkcmVzcyBmaWVsZFxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgXCJOYW1lIDxhZGRyZXNzQGRvbWFpbj5cIlxuICpcbiAqIHdpbGwgYmUgY29udmVydGVkIHRvXG4gKlxuICogICAgIFt7bmFtZTogXCJOYW1lXCIsIGFkZHJlc3M6IFwiYWRkcmVzc0Bkb21haW5cIn1dXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZH0gYWRkcmVzcyBBZGRyZXNzIGZpZWxkXG4gKiBAcmV0dXJuIHtBZGRyZXNzT2JqZWN0W119IEFuIGFycmF5IG9mIGFkZHJlc3Mgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBhZGRyZXNzcGFyc2VyKGFkZHJlc3MpIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbml6ZUFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdvcGVyYXRvcicgJiZcbiAgICAgICAgICAgICh0b2tlbi52YWx1ZSA9PT0gJywnIHx8IHRva2VuLnZhbHVlID09PSAnOycpKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaCguLi5jb252ZXJ0QWRkcmVzc1Rva2Vucyh0b2tlbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBhZGRyZXNzZXMucHVzaCguLi5jb252ZXJ0QWRkcmVzc1Rva2Vucyh0b2tlbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3Nlcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RhdGV9IFtkYXRlXSBhbiBvcHRpb25hbCBkYXRlIHRvIGNvbnZlcnQgdG8gUkZDMjgyMiBmb3JtYXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZVV0Y10gd2hldGhlciB0byBwYXJzZSB0aGUgZGF0ZSBhcyBVVEMgKGRlZmF1bHQ6IGZhbHNlKVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGNvbnZlcnRlZCBkYXRlXG4gKi9cbmZ1bmN0aW9uIGdldFJGQzI4MjJEYXRlKGRhdGUgPSBuZXcgRGF0ZSgpLCB1c2VVdGMgPSBmYWxzZSkge1xuICAgIGlmICh1c2VVdGMpIHtcbiAgICAgICAgcmV0dXJuIGdldFJGQzI4MjJEYXRlVVRDKGRhdGUpO1xuICAgIH1cbiAgICBjb25zdCBkYXRlcyA9IGRhdGVcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnJlcGxhY2UoJ0dNVCcsICcnKVxuICAgICAgICAucmVwbGFjZSgvXFxzXFwoLipcXCkkLywgJycpXG4gICAgICAgIC5zcGxpdCgnICcpO1xuICAgIGRhdGVzWzBdID0gZGF0ZXNbMF0gKyAnLCc7XG4gICAgY29uc3QgZGF5ID0gZGF0ZXNbMV07XG4gICAgZGF0ZXNbMV0gPSBkYXRlc1syXTtcbiAgICBkYXRlc1syXSA9IGRheTtcbiAgICByZXR1cm4gZGF0ZXMuam9pbignICcpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0RhdGV9IFtkYXRlXSBhbiBvcHRpb25hbCBkYXRlIHRvIGNvbnZlcnQgdG8gUkZDMjgyMiBmb3JtYXQgKFVUQylcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjb252ZXJ0ZWQgZGF0ZVxuICovXG5mdW5jdGlvbiBnZXRSRkMyODIyRGF0ZVVUQyhkYXRlID0gbmV3IERhdGUoKSkge1xuICAgIGNvbnN0IGRhdGVzID0gZGF0ZS50b1VUQ1N0cmluZygpLnNwbGl0KCcgJyk7XG4gICAgZGF0ZXMucG9wKCk7IC8vIHJlbW92ZSB0aW1lem9uZVxuICAgIGRhdGVzLnB1c2goJyswMDAwJyk7XG4gICAgcmV0dXJuIGRhdGVzLmpvaW4oJyAnKTtcbn1cbi8qKlxuICogUkZDIDI4MjIgcmVnZXhcbiAqIEBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvYmxvYi9hODMxZmM3ZTI2OTQyODFjZTMxZTRmMDkwYmJjZjkwYTY5MGYwMjc3L3NyYy9saWIvY3JlYXRlL2Zyb20tc3RyaW5nLmpzI0wxMDFcbiAqL1xuY29uc3QgcmZjMjgyMnJlID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLztcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtkYXRlXSBhIHN0cmluZyB0byBjaGVjayBmb3IgY29uZm9ybWFuY2UgdG8gdGhlIFtyZmMyODIyXShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuMykgc3RhbmRhcmRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSBjb25mb3JtYW5jZSBjaGVja1xuICovXG5mdW5jdGlvbiBpc1JGQzI4MjJEYXRlKGRhdGUpIHtcbiAgICByZXR1cm4gcmZjMjgyMnJlLnRlc3QoZGF0ZSk7XG59XG5cbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZW1haWxqcy9lbWFpbGpzLW1pbWUtY29kZWMvYmxvYi82OTA5YzcwNmI5ZjA5YmMwZTVjM2ZhZjQ4ZjcyM2NjYTUzZTViMzUyL3NyYy9taW1lY29kZWMuanNcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbi8qKlxuICogQHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjA0NSNzZWN0aW9uLTYuN1xuICovXG5jb25zdCBSQU5HRVMgPSBbXG4gICAgWzB4MDldLFxuICAgIFsweDBhXSxcbiAgICBbMHgwZF0sXG4gICAgWzB4MjAsIDB4M2NdLFxuICAgIFsweDNlLCAweDdlXSwgLy8gPj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1cbl07XG5jb25zdCBMT09LVVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuY29uc3QgTUFYX0NIVU5LX0xFTkdUSCA9IDE2MzgzOyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcbmNvbnN0IE1BWF9NSU1FX1dPUkRfTEVOR1RIID0gNTI7XG5jb25zdCBNQVhfQjY0X01JTUVfV09SRF9CWVRFX0xFTkdUSCA9IDM5O1xuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkge1xuICAgIHJldHVybiAoTE9PS1VQWyhudW0gPj4gMTgpICYgMHgzZl0gK1xuICAgICAgICBMT09LVVBbKG51bSA+PiAxMikgJiAweDNmXSArXG4gICAgICAgIExPT0tVUFsobnVtID4+IDYpICYgMHgzZl0gK1xuICAgICAgICBMT09LVVBbbnVtICYgMHgzZl0pO1xufVxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICAgICAgb3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCgodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArIHVpbnQ4W2kgKyAyXSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBlbmNvZGVCYXNlNjQoZGF0YSkge1xuICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBNQVhfQ0hVTktfTEVOR1RIKSB7XG4gICAgICAgIG91dHB1dCArPSBlbmNvZGVDaHVuayhkYXRhLCBpLCBpICsgTUFYX0NIVU5LX0xFTkdUSCA+IGxlbjIgPyBsZW4yIDogaSArIE1BWF9DSFVOS19MRU5HVEgpO1xuICAgIH1cbiAgICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gICAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgdG1wID0gZGF0YVtsZW4gLSAxXTtcbiAgICAgICAgb3V0cHV0ICs9IExPT0tVUFt0bXAgPj4gMl07XG4gICAgICAgIG91dHB1dCArPSBMT09LVVBbKHRtcCA8PCA0KSAmIDB4M2ZdO1xuICAgICAgICBvdXRwdXQgKz0gJz09JztcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgICAgICBjb25zdCB0bXAgPSAoZGF0YVtsZW4gLSAyXSA8PCA4KSArIGRhdGFbbGVuIC0gMV07XG4gICAgICAgIG91dHB1dCArPSBMT09LVVBbdG1wID4+IDEwXTtcbiAgICAgICAgb3V0cHV0ICs9IExPT0tVUFsodG1wID4+IDQpICYgMHgzZl07XG4gICAgICAgIG91dHB1dCArPSBMT09LVVBbKHRtcCA8PCAyKSAmIDB4M2ZdO1xuICAgICAgICBvdXRwdXQgKz0gJz0nO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuLyoqXG4gKiBTcGxpdHMgYSBtaW1lIGVuY29kZWQgc3RyaW5nLiBOZWVkZWQgZm9yIGRpdmlkaW5nIG1pbWUgd29yZHMgaW50byBzbWFsbGVyIGNodW5rc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgTWltZSBlbmNvZGVkIHN0cmluZyB0byBiZSBzcGxpdCB1cFxuICogQHBhcmFtIHtudW1iZXJ9IG1heGxlbiBNYXhpbXVtIGxlbmd0aCBvZiBjaGFyYWN0ZXJzIGZvciBvbmUgcGFydCAobWluaW11bSAxMilcbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBsaW5lc1xuICovXG5mdW5jdGlvbiBzcGxpdE1pbWVFbmNvZGVkU3RyaW5nKHN0ciwgbWF4bGVuID0gMTIpIHtcbiAgICBjb25zdCBtaW5Xb3JkTGVuZ3RoID0gMTI7IC8vIHJlcXVpcmUgYXQgbGVhc3QgMTIgc3ltYm9scyB0byBmaXQgcG9zc2libGUgNCBvY3RldCBVVEYtOCBzZXF1ZW5jZXNcbiAgICBjb25zdCBtYXhXb3JkTGVuZ3RoID0gTWF0aC5tYXgobWF4bGVuLCBtaW5Xb3JkTGVuZ3RoKTtcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBjdXJMaW5lID0gc3RyLnN1YnN0cigwLCBtYXhXb3JkTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjdXJMaW5lLm1hdGNoKC89WzAtOUEtRl0/JC9pKTsgLy8gc2tpcCBpbmNvbXBsZXRlIGVzY2FwZWQgY2hhclxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGN1ckxpbmUgPSBjdXJMaW5lLnN1YnN0cigwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICBsZXQgY2hyO1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHN0ci5zdWJzdHIoY3VyTGluZS5sZW5ndGgpLm1hdGNoKC9ePShbMC05QS1GXXsyfSkvaSk7IC8vIGNoZWNrIGlmIG5vdCBtaWRkbGUgb2YgYSB1bmljb2RlIGNoYXIgc2VxdWVuY2VcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGNociA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XG4gICAgICAgICAgICAgICAgLy8gaW52YWxpZCBzZXF1ZW5jZSwgbW92ZSBvbmUgY2hhciBiYWNrIGFuYyByZWNoZWNrXG4gICAgICAgICAgICAgICAgaWYgKGNociA8IDB4YzIgJiYgY2hyID4gMHg3Zikge1xuICAgICAgICAgICAgICAgICAgICBjdXJMaW5lID0gY3VyTGluZS5zdWJzdHIoMCwgY3VyTGluZS5sZW5ndGggLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyTGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goY3VyTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cihjdXJMaW5lLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuciBudW1iZXJcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiBudW1iZXIgaXMgaW4gcmFuZ2VcbiAqL1xuZnVuY3Rpb24gY2hlY2tSYW5nZXMobnIpIHtcbiAgICByZXR1cm4gUkFOR0VTLnJlZHVjZSgodmFsLCByYW5nZSkgPT4gdmFsIHx8XG4gICAgICAgIChyYW5nZS5sZW5ndGggPT09IDEgJiYgbnIgPT09IHJhbmdlWzBdKSB8fFxuICAgICAgICAocmFuZ2UubGVuZ3RoID09PSAyICYmIG5yID49IHJhbmdlWzBdICYmIG5yIDw9IHJhbmdlWzFdKSwgZmFsc2UpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24gcHJpbnRhYmxlIGFuZCBub24gYXNjaWkgYnl0ZXMgdG8gPVhYIGZvcm0sIHdoZXJlIFhYIGlzIHRoZVxuICogYnl0ZSB2YWx1ZSBpbiBoZXguIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29udmVydCBsaW5lYnJlYWtzIGV0Yy4gaXRcbiAqIG9ubHkgZXNjYXBlcyBjaGFyYWN0ZXIgc2VxdWVuY2VzXG4gKlxuICogTk9URTogRW5jb2Rpbmcgc3VwcG9ydCBkZXBlbmRzIG9uIHV0aWwuVGV4dERlY29kZXIsIHdoaWNoIGlzIHNldmVyZWx5IGxpbWl0ZWRcbiAqIHByaW9yIHRvIE5vZGUuanMgMTMuXG4gKlxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3V0aWwuaHRtbCN1dGlsX3doYXR3Z19zdXBwb3J0ZWRfZW5jb2RpbmdzXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMTkyMTRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSBkYXRhIEVpdGhlciBhIHN0cmluZyBvciBhbiBVaW50OEFycmF5XG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgV0hBVFdHIHN1cHBvcnRlZCBlbmNvZGluZ1xuICogQHJldHVybiB7c3RyaW5nfSBNaW1lIGVuY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIG1pbWVFbmNvZGUoZGF0YSA9ICcnLCBlbmNvZGluZyA9ICd1dGYtOCcpIHtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nKTtcbiAgICBjb25zdCBidWZmZXIgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBlbmNvZGVyLmVuY29kZShkYXRhKVxuICAgICAgICA6IGVuY29kZXIuZW5jb2RlKGRlY29kZXIuZGVjb2RlKGRhdGEpKTtcbiAgICByZXR1cm4gYnVmZmVyLnJlZHVjZSgoYWdncmVnYXRlLCBvcmQsIGluZGV4KSA9PiBjaGVja1JhbmdlcyhvcmQpICYmXG4gICAgICAgICEoKG9yZCA9PT0gMHgyMCB8fCBvcmQgPT09IDB4MDkpICYmXG4gICAgICAgICAgICAoaW5kZXggPT09IGJ1ZmZlci5sZW5ndGggLSAxIHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgMV0gPT09IDB4MGEgfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyAxXSA9PT0gMHgwZCkpXG4gICAgICAgID8gLy8gaWYgdGhlIGNoYXIgaXMgaW4gYWxsb3dlZCByYW5nZSwgdGhlbiBrZWVwIGFzIGlzLCB1bmxlc3MgaXQgaXMgYSB3cyBpbiB0aGUgZW5kIG9mIGEgbGluZVxuICAgICAgICAgICAgYWdncmVnYXRlICsgU3RyaW5nLmZyb21DaGFyQ29kZShvcmQpXG4gICAgICAgIDogYCR7YWdncmVnYXRlfT0ke29yZCA8IDB4MTAgPyAnMCcgOiAnJ30ke29yZFxuICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgLnRvVXBwZXJDYXNlKCl9YCwgJycpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgc3RyaW5nIG9yIGFuIFVpbnQ4QXJyYXkgdG8gYW4gVVRGLTggTUlNRSBXb3JkXG4gKlxuICogTk9URTogRW5jb2Rpbmcgc3VwcG9ydCBkZXBlbmRzIG9uIHV0aWwuVGV4dERlY29kZXIsIHdoaWNoIGlzIHNldmVyZWx5IGxpbWl0ZWRcbiAqIHByaW9yIHRvIE5vZGUuanMgMTMuXG4gKlxuICogQHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjA0N1xuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3V0aWwuaHRtbCN1dGlsX3doYXR3Z19zdXBwb3J0ZWRfZW5jb2RpbmdzXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMTkyMTRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSBkYXRhIFN0cmluZyB0byBiZSBlbmNvZGVkXG4gKiBAcGFyYW0geydRJyB8ICdCJ30gbWltZVdvcmRFbmNvZGluZz0nUScgRW5jb2RpbmcgZm9yIHRoZSBtaW1lIHdvcmQsIGVpdGhlciBRIG9yIEJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBXSEFUV0cgc3VwcG9ydGVkIGVuY29kaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFNpbmdsZSBvciBzZXZlcmFsIG1pbWUgd29yZHMgam9pbmVkIHRvZ2V0aGVyXG4gKi9cbmZ1bmN0aW9uIG1pbWVXb3JkRW5jb2RlKGRhdGEsIG1pbWVXb3JkRW5jb2RpbmcgPSAnUScsIGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpO1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBkZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICBpZiAobWltZVdvcmRFbmNvZGluZyA9PT0gJ1EnKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWRTdHIgPSBtaW1lRW5jb2RlKHN0ciwgZW5jb2RpbmcpLnJlcGxhY2UoL1teYS16MC05ISorXFwtLz1dL2dpLCAoY2hyKSA9PiBjaHIgPT09ICcgJ1xuICAgICAgICAgICAgPyAnXydcbiAgICAgICAgICAgIDogJz0nICtcbiAgICAgICAgICAgICAgICAoY2hyLmNoYXJDb2RlQXQoMCkgPCAweDEwID8gJzAnIDogJycpICtcbiAgICAgICAgICAgICAgICBjaHIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIHBhcnRzID1cbiAgICAgICAgICAgIGVuY29kZWRTdHIubGVuZ3RoIDwgTUFYX01JTUVfV09SRF9MRU5HVEhcbiAgICAgICAgICAgICAgICA/IFtlbmNvZGVkU3RyXVxuICAgICAgICAgICAgICAgIDogc3BsaXRNaW1lRW5jb2RlZFN0cmluZyhlbmNvZGVkU3RyLCBNQVhfTUlNRV9XT1JEX0xFTkdUSCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGaXRzIGFzIG11Y2ggYXMgcG9zc2libGUgaW50byBldmVyeSBsaW5lIHdpdGhvdXQgYnJlYWtpbmcgdXRmLTggbXVsdGlieXRlIGNoYXJhY3RlcnMnIG9jdGV0cyB1cCBhY3Jvc3MgbGluZXNcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGVuY29kZXIuZW5jb2RlKHN0ci5zdWJzdHJpbmcoaiwgaSkpLmxlbmd0aCA+XG4gICAgICAgICAgICAgICAgTUFYX0I2NF9NSU1FX1dPUkRfQllURV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSB3ZW50IG9uZSBjaGFyYWN0ZXIgdG9vIGZhciwgc3Vic3RyaW5nIGF0IHRoZSBjaGFyIGJlZm9yZVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goc3RyLnN1YnN0cmluZyhqLCBpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGogPSBpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIHJlbWFpbmRlciBvZiB0aGUgc3RyaW5nXG4gICAgICAgIHN0ci5zdWJzdHJpbmcoaikgJiYgcGFydHMucHVzaChzdHIuc3Vic3RyaW5nKGopKTtcbiAgICAgICAgcGFydHMgPSBwYXJ0cy5tYXAoKHgpID0+IGVuY29kZXIuZW5jb2RlKHgpKS5tYXAoKHgpID0+IGVuY29kZUJhc2U2NCh4KSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0c1xuICAgICAgICAubWFwKChwKSA9PiBgPT9VVEYtOD8ke21pbWVXb3JkRW5jb2Rpbmd9PyR7cH0/PSBgKVxuICAgICAgICAuam9pbignJylcbiAgICAgICAgLnRyaW0oKTtcbn1cblxuY29uc3QgQ1JMRiQxID0gJ1xcclxcbic7XG4vKipcbiAqIE1JTUUgc3RhbmRhcmQgd2FudHMgNzYgY2hhciBjaHVua3Mgd2hlbiBzZW5kaW5nIG91dC5cbiAqL1xuY29uc3QgTUlNRUNIVU5LID0gNzY7XG4vKipcbiAqIG1lZXRzIGJvdGggYmFzZTY0IGFuZCBtaW1lIGRpdmlzaWJpbGl0eVxuICovXG5jb25zdCBNSU1FNjRDSFVOSyA9IChNSU1FQ0hVTksgKiA2KTtcbi8qKlxuICogc2l6ZSBvZiB0aGUgbWVzc2FnZSBzdHJlYW0gYnVmZmVyXG4gKi9cbmNvbnN0IEJVRkZFUlNJWkUgPSAoTUlNRUNIVU5LICogMjQgKiA3KTtcbmxldCBjb3VudGVyID0gMDtcbmZ1bmN0aW9uIGdlbmVyYXRlQm91bmRhcnkoKSB7XG4gICAgbGV0IHRleHQgPSAnJztcbiAgICBjb25zdCBwb3NzaWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknKCkrXywtLi86PT9cIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY5OyBpKyspIHtcbiAgICAgICAgdGV4dCArPSBwb3NzaWJsZS5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9zc2libGUubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gY29udmVydFBlcnNvblRvQWRkcmVzcyhwZXJzb24pIHtcbiAgICByZXR1cm4gYWRkcmVzc3BhcnNlcihwZXJzb24pXG4gICAgICAgIC5tYXAoKHsgbmFtZSwgYWRkcmVzcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBuYW1lXG4gICAgICAgICAgICA/IGAke21pbWVXb3JkRW5jb2RlKG5hbWUpLnJlcGxhY2UoLywvZywgJz0yQycpfSA8JHthZGRyZXNzfT5gXG4gICAgICAgICAgICA6IGFkZHJlc3M7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJywgJyk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGFzaERlbGltaXRlZFRleHRUb1NuYWtlQ2FzZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHRcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnJlcGxhY2UoL14oLil8LSguKS9nLCAobWF0Y2gpID0+IG1hdGNoLnRvVXBwZXJDYXNlKCkpO1xufVxuY2xhc3MgTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIHJmYzI4MjItY29tcGxpYW50IG1lc3NhZ2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogU3BlY2lhbCBub3RlczpcbiAgICAgKiAtIFRoZSBgZnJvbWAgZmllbGQgaXMgcmVxdWlyZWQuXG4gICAgICogLSBBdCBsZWFzdCBvbmUgYHRvYCwgYGNjYCwgb3IgYGJjY2AgaGVhZGVyIGlzIGFsc28gcmVxdWlyZWQuXG4gICAgICogLSBZb3UgY2FuIGFsc28gYWRkIHdoYXRldmVyIG90aGVyIGhlYWRlcnMgeW91IHdhbnQuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsPE1lc3NhZ2VIZWFkZXJzPn0gaGVhZGVycyBNZXNzYWdlIGhlYWRlcnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuYXR0YWNobWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWFkZXIgPSB7XG4gICAgICAgICAgICAnbWVzc2FnZS1pZCc6IGA8JHtuZXcgRGF0ZSgpLmdldFRpbWUoKX0uJHtjb3VudGVyKyt9LiR7cHJvY2Vzcy5waWR9QCR7aG9zdG5hbWUoKX0+YCxcbiAgICAgICAgICAgIGRhdGU6IGdldFJGQzI4MjJEYXRlKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udGVudCA9ICd0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04JztcbiAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZSA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IHVzZXIgdG8gb3ZlcnJpZGUgZGVmYXVsdCBjb250ZW50LXR5cGUgdG8gb3ZlcnJpZGUgY2hhcnNldCBvciBzZW5kIGEgc2luZ2xlIG5vbi10ZXh0IG1lc3NhZ2VcbiAgICAgICAgICAgIGlmICgvXmNvbnRlbnQtdHlwZSQvaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBoZWFkZXJzW2hlYWRlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZWFkZXIgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlYWRlciA9PT0gJ2F0dGFjaG1lbnQnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGhlYWRlcnNbaGVhZGVyXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50ID0gaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dGFjaG1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0YWNobWVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2goYXR0YWNobWVudFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0YWNobWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoKGF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlYWRlciA9PT0gJ3N1YmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXIuc3ViamVjdCA9IG1pbWVXb3JkRW5jb2RlKGhlYWRlcnMuc3ViamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXihjY3xiY2N8dG98ZnJvbSkvaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcltoZWFkZXIudG9Mb3dlckNhc2UoKV0gPSBjb252ZXJ0UGVyc29uVG9BZGRyZXNzKGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBhbnkgaGVhZGVycyB0aGUgdXNlciB3YW50cyB0byBzZXQ/P1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBmaWxlIHRvIHRoZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgZWFjaCBhZGRpbmcgYSBuZXcgYXR0YWNobWVudC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VBdHRhY2htZW50fSBvcHRpb25zIGF0dGFjaG1lbnQgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNZXNzYWdlfSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBhdHRhY2gob3B0aW9ucykge1xuICAgICAgICAvLyBzZW5kZXIgY2FuIHNwZWNpZnkgYW4gYXR0YWNobWVudCBhcyBhbiBhbHRlcm5hdGl2ZVxuICAgICAgICBpZiAob3B0aW9ucy5hbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZSA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0aXZlLmNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQgfHwgJ3V0Zi04JztcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmUudHlwZSA9IG9wdGlvbnMudHlwZSB8fCAndGV4dC9odG1sJztcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmUuaW5saW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudHMucHVzaChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHt7IGlzVmFsaWQ6IGJvb2xlYW4sIHZhbGlkYXRpb25FcnJvcjogKHN0cmluZyB8IHVuZGVmaW5lZCkgfX0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgd2hldGhlciB0aGlzIG1lc3NhZ2UgaXMgdmFsaWRseSBmb3JtYXR0ZWQsIGFuZCB0aGUgZmlyc3QgdmFsaWRhdGlvbiBlcnJvciBpZiBpdCBpcyBub3QuXG4gICAgICovXG4gICAgY2hlY2tWYWxpZGl0eSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhlYWRlci5mcm9tICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmhlYWRlci5mcm9tKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yOiAnTWVzc2FnZSBtdXN0IGhhdmUgYSBgZnJvbWAgaGVhZGVyJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhlYWRlci50byAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5oZWFkZXIudG8pID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuaGVhZGVyLmNjICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmhlYWRlci5jYykgPT09IGZhbHNlICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5oZWFkZXIuYmNjICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmhlYWRlci5iY2MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3I6ICdNZXNzYWdlIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYHRvYCwgYGNjYCwgb3IgYGJjY2AgaGVhZGVyJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXR0YWNobWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZmFpbGVkID0gW107XG4gICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnRzLmZvckVhY2goKGF0dGFjaG1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudC5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdHNTeW5jKGF0dGFjaG1lbnQucGF0aCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWQucHVzaChgJHthdHRhY2htZW50LnBhdGh9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0YWNobWVudC5zdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRhY2htZW50LnN0cmVhbS5yZWFkYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkLnB1c2goJ2F0dGFjaG1lbnQgc3RyZWFtIGlzIG5vdCByZWFkYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdHRhY2htZW50LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkLnB1c2goJ2F0dGFjaG1lbnQgaGFzIG5vIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IGZhaWxlZC5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yOiBmYWlsZWQuam9pbignLCAnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSwgdmFsaWRhdGlvbkVycm9yOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBkZXByZWNhdGVkIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIGBlcnJiYWNrYCBzdHlsZSBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZiB0aGUgbGlicmFyeSwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiB1c2UgYGNoZWNrVmFsaWRpdHlgIGluc3RlYWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihpc1ZhbGlkOiBib29sZWFuLCBpbnZhbGlkUmVhc29uOiAoc3RyaW5nIHwgdW5kZWZpbmVkKSk6IHZvaWR9IGNhbGxiYWNrIC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB2YWxpZChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbGlkYXRpb25FcnJvciB9ID0gdGhpcy5jaGVja1ZhbGlkaXR5KCk7XG4gICAgICAgIGNhbGxiYWNrKGlzVmFsaWQsIHZhbGlkYXRpb25FcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJucyB7TWVzc2FnZVN0cmVhbX0gYSBzdHJlYW0gb2YgdGhlIGN1cnJlbnQgbWVzc2FnZVxuICAgICAqL1xuICAgIHN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlU3RyZWFtKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgc3RyaW5nKTogdm9pZH0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCB0aGUgZXJyb3IgYW5kIGJ1ZmZlclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHJlYWQoY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICBjb25zdCBzdHIgPSB0aGlzLnN0cmVhbSgpO1xuICAgICAgICBzdHIub24oJ2RhdGEnLCAoZGF0YSkgPT4gKGJ1ZmZlciArPSBkYXRhKSk7XG4gICAgICAgIHN0ci5vbignZW5kJywgKGVycikgPT4gY2FsbGJhY2soZXJyLCBidWZmZXIpKTtcbiAgICAgICAgc3RyLm9uKCdlcnJvcicsIChlcnIpID0+IGNhbGxiYWNrKGVyciwgYnVmZmVyKSk7XG4gICAgfVxuICAgIHJlYWRBc3luYygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVhZCgoZXJyLCBidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIE1lc3NhZ2VTdHJlYW0gZXh0ZW5kcyBTdHJlYW0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBzdHJlYW1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhNSU1FQ0hVTksgKiAyNCAqIDcpO1xuICAgICAgICB0aGlzLmJ1ZmZlckluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YV0gdGhlIGRhdGEgdG8gb3V0cHV0XG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdGhlIGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7YW55W119IFthcmdzXSBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gY2FuIHdlIGJ1ZmZlciB0aGUgZGF0YT9cbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgKyB0aGlzLmJ1ZmZlckluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLndyaXRlKGRhdGEsIHRoaXMuYnVmZmVySW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckluZGV4ICs9IGJ5dGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCBidWZmZXIgdGhlIGRhdGEsIHNvIHNoaXAgaXQgb3V0IVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzID4gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCB0aGlzLmJ1ZmZlci50b1N0cmluZygndXRmLTgnLCAwLCB0aGlzLmJ1ZmZlckluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29wcyA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsb29wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxvb3AgPCBsb29wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YS5zdWJzdHJpbmcodGhpcy5idWZmZXIubGVuZ3RoICogbG9vcCwgdGhpcy5idWZmZXIubGVuZ3RoICogKGxvb3AgKyAxKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyB3ZSBuZWVkIHRvIGNsZWFuIG91dCB0aGUgYnVmZmVyLCBpdCBpcyBnZXR0aW5nIGZ1bGxcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgdGhpcy5idWZmZXIudG9TdHJpbmcoJ3V0Zi04JywgMCwgdGhpcy5idWZmZXJJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIud3JpdGUoZGF0YSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckluZGV4ID0gYnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCBlbXB0eSBvdXQgdGhlIGJ1ZmZlciwgc28gbGV0J3Mgd2FpdCB0aWxsIHdlIHJlc3VtZSBiZWZvcmUgYWRkaW5nIHRvIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ3Jlc3VtZScsICgpID0+IG91dHB1dChkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge01lc3NhZ2VBdHRhY2htZW50fSBbYXR0YWNobWVudF0gdGhlIGF0dGFjaG1lbnQgd2hvc2UgaGVhZGVycyB5b3Ugd291bGQgbGlrZSB0byBvdXRwdXRcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvdXRwdXRBdHRhY2htZW50SGVhZGVycyA9IChhdHRhY2htZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogYXR0YWNobWVudC50eXBlICtcbiAgICAgICAgICAgICAgICAgICAgKGF0dGFjaG1lbnQuY2hhcnNldCA/IGA7IGNoYXJzZXQ9JHthdHRhY2htZW50LmNoYXJzZXR9YCA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChhdHRhY2htZW50Lm1ldGhvZCA/IGA7IG1ldGhvZD0ke2F0dGFjaG1lbnQubWV0aG9kfWAgOiAnJyksXG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmcnOiAnYmFzZTY0JyxcbiAgICAgICAgICAgICAgICAnY29udGVudC1kaXNwb3NpdGlvbic6IGF0dGFjaG1lbnQuaW5saW5lXG4gICAgICAgICAgICAgICAgICAgID8gJ2lubGluZSdcbiAgICAgICAgICAgICAgICAgICAgOiBgYXR0YWNobWVudDsgZmlsZW5hbWU9XCIke21pbWVXb3JkRW5jb2RlKGF0dGFjaG1lbnQubmFtZSl9XCJgLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGFsbG93IHNlbmRlciB0byBvdmVycmlkZSBkZWZhdWx0IGhlYWRlcnNcbiAgICAgICAgICAgIGlmIChhdHRhY2htZW50LmhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGF0dGFjaG1lbnQuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IGF0dGFjaG1lbnQuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0RGFzaERlbGltaXRlZFRleHRUb1NuYWtlQ2FzZShoZWFkZXIpLFxuICAgICAgICAgICAgICAgICAgICAnOiAnLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2hlYWRlcl0sXG4gICAgICAgICAgICAgICAgICAgIENSTEYkMSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dChkYXRhLmNvbmNhdChbQ1JMRiQxXSkuam9pbignJykpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgdGhlIGRhdGEgdG8gb3V0cHV0IGFzIGJhc2U2NFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjYWxsYmFja10gdGhlIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgb3V0cHV0IGlzIGZpbmlzaGVkXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgb3V0cHV0QmFzZTY0ID0gKGRhdGEsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb29wcyA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIE1JTUVDSFVOSyk7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAobG9vcCA8IGxvb3BzKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0KGRhdGEuc3Vic3RyaW5nKE1JTUVDSFVOSyAqIGxvb3AsIE1JTUVDSFVOSyAqIChsb29wICsgMSkpICsgQ1JMRiQxKTtcbiAgICAgICAgICAgICAgICBsb29wKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvdXRwdXRGaWxlID0gKGF0dGFjaG1lbnQsIG5leHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gTUlNRTY0Q0hVTksgKiAxNjtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhjaHVuayk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dEVuY29kaW5nID0gKChfYSA9IGF0dGFjaG1lbnQgPT09IG51bGwgfHwgYXR0YWNobWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXR0YWNobWVudC5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJ2NvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmcnXSkgfHwgJ2Jhc2U2NCc7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IGlucHV0RW5jb2RpbmcgPT09ICc3Yml0J1xuICAgICAgICAgICAgICAgID8gJ2FzY2lpJ1xuICAgICAgICAgICAgICAgIDogaW5wdXRFbmNvZGluZyA9PT0gJzhiaXQnXG4gICAgICAgICAgICAgICAgICAgID8gJ2JpbmFyeSdcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dEVuY29kaW5nO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgdGhlIGVycm9yIHRvIGVtaXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmZCB0aGUgZmlsZSBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgb3BlbmVkID0gKGVyciwgZmQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRCeXRlcyA9IChlcnIsIGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgdGhpcy5yZWFkYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIgfHwgbmV3IEVycm9yKCdtZXNzYWdlIHN0cmVhbSB3YXMgaW50ZXJydXB0ZWQgc29tZWhvdyEnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZ3VhcmFudGVlZCB0byBiZSBlbmNvZGVkIHdpdGhvdXQgcGFkZGluZyB1bmxlc3MgaXQgaXMgb3VyIGxhc3QgcmVhZFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRCYXNlNjQoYnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nLCAwLCBieXRlcyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcyA9PSBjaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlYWQgYSBmdWxsIGNodW5rLCB0aGVyZSBtaWdodCBiZSBtb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZChmZCwgYnVmZmVyLCAwLCBjaHVuaywgbnVsbCwgcmVhZEJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gdGhhdCB3YXMgdGhlIGxhc3QgY2h1bmssIHdlIGFyZSBkb25lIHJlYWRpbmcgdGhlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgY2xvc2VTeW5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZShmZCwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZChmZCwgYnVmZmVyLCAwLCBjaHVuaywgbnVsbCwgcmVhZEJ5dGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgY2xvc2VTeW5jKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvcGVuKGF0dGFjaG1lbnQucGF0aCwgJ3InLCBvcGVuZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtNZXNzYWdlQXR0YWNobWVudH0gYXR0YWNobWVudCB0aGUgbWV0YWRhdGEgdG8gdXNlIGFzIGhlYWRlcnNcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciBvdXRwdXQgaXMgZmluaXNoZWRcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvdXRwdXRTdHJlYW0gPSAoYXR0YWNobWVudCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RyZWFtIH0gPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgaWYgKHN0cmVhbSA9PT0gbnVsbCB8fCBzdHJlYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cmVhbS5yZWFkYWJsZSkge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2aW91cyA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEJhc2U2NChwcmV2aW91cy50b1N0cmluZygnYmFzZTY0JyksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncGF1c2UnLCBzdHJlYW0ucGF1c2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZXN1bWUnLCBzdHJlYW0ucmVzdW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzdHJlYW0ucmVzdW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCAoYnVmZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyB3ZSBoYXZlIGJ5dGVzIGZyb20gYSBwcmV2aW91cyBzdHJlYW0gZGF0YSBldmVudD9cbiAgICAgICAgICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihidWZmKSA/IGJ1ZmYgOiBCdWZmZXIuZnJvbShidWZmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtwcmV2aW91cywgYnVmZmVyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGVkID0gYnVmZmVyLmxlbmd0aCAlIE1JTUU2NENIVU5LO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IEJ1ZmZlci5hbGxvYyhwYWRkZWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGUgYXMgbXVjaCBvZiB0aGUgYnVmZmVyIHRvIGJhc2U2NCB3aXRob3V0IGVtcHR5IGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWRkZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGRhbmdsaW5nIGJ5dGVzIGludG8gcHJldmlvdXMgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuY29weShwcmV2aW91cywgMCwgYnVmZmVyLmxlbmd0aCAtIHBhZGRlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0QmFzZTY0KGJ1ZmZlci50b1N0cmluZygnYmFzZTY0JywgMCwgYnVmZmVyLmxlbmd0aCAtIHBhZGRlZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMub24oJ3BhdXNlJywgc3RyZWFtLnBhdXNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdyZXN1bWUnLCBzdHJlYW0ucmVzdW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdlcnJvcicsIHN0cmVhbS5yZXN1bWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHsgbWVzc2FnZTogJ3N0cmVhbSBub3QgcmVhZGFibGUnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvdXRwdXRBdHRhY2htZW50ID0gKGF0dGFjaG1lbnQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBidWlsZCA9IGF0dGFjaG1lbnQucGF0aFxuICAgICAgICAgICAgICAgID8gb3V0cHV0RmlsZVxuICAgICAgICAgICAgICAgIDogYXR0YWNobWVudC5zdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgPyBvdXRwdXRTdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgOiBvdXRwdXREYXRhO1xuICAgICAgICAgICAgb3V0cHV0QXR0YWNobWVudEhlYWRlcnMoYXR0YWNobWVudCk7XG4gICAgICAgICAgICBidWlsZChhdHRhY2htZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYm91bmRhcnkgdGhlIGJvdW5kYXJ5IHRleHQgYmV0d2VlbiBvdXRwdXRzXG4gICAgICAgICAqIEBwYXJhbSB7TWVzc2FnZUF0dGFjaG1lbnRbXX0gbGlzdCB0aGUgbGlzdCBvZiBwb3RlbnRpYWwgbWVzc2FnZXMgdG8gb3V0cHV0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIGxpc3QgaXRlbSB0byBvdXRwdXRcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBpZiBpbmRleCBpcyBncmVhdGVyIHRoYW4gdXBwZXIgYm91bmRcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvdXRwdXRNZXNzYWdlID0gKGJvdW5kYXJ5LCBsaXN0LCBpbmRleCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0KGAtLSR7Ym91bmRhcnl9JHtDUkxGJDF9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RbaW5kZXhdLnJlbGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0UmVsYXRlZChsaXN0W2luZGV4XSwgKCkgPT4gb3V0cHV0TWVzc2FnZShib3VuZGFyeSwgbGlzdCwgaW5kZXggKyAxLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0QXR0YWNobWVudChsaXN0W2luZGV4XSwgKCkgPT4gb3V0cHV0TWVzc2FnZShib3VuZGFyeSwgbGlzdCwgaW5kZXggKyAxLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dChgJHtDUkxGJDF9LS0ke2JvdW5kYXJ5fS0tJHtDUkxGJDF9JHtDUkxGJDF9YCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3V0cHV0TWl4ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib3VuZGFyeSA9IGdlbmVyYXRlQm91bmRhcnkoKTtcbiAgICAgICAgICAgIG91dHB1dChgQ29udGVudC1UeXBlOiBtdWx0aXBhcnQvbWl4ZWQ7IGJvdW5kYXJ5PVwiJHtib3VuZGFyeX1cIiR7Q1JMRiQxfSR7Q1JMRiQxfS0tJHtib3VuZGFyeX0ke0NSTEYkMX1gKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lc3NhZ2UuYWx0ZXJuYXRpdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dFRleHQodGhpcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBvdXRwdXRNZXNzYWdlKGJvdW5kYXJ5LCB0aGlzLm1lc3NhZ2UuYXR0YWNobWVudHMsIDAsIGNsb3NlJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0QWx0ZXJuYXRpdmUoXG4gICAgICAgICAgICAgICAgLy8gdHlwZXNjcmlwdCBidWc7IHNob3VsZCBuYXJyb3cgdG8geyBhbHRlcm5hdGl2ZTogTWVzc2FnZUF0dGFjaG1lbnQgfVxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSwgKCkgPT4gb3V0cHV0TWVzc2FnZShib3VuZGFyeSwgdGhpcy5tZXNzYWdlLmF0dGFjaG1lbnRzLCAwLCBjbG9zZSQxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge01lc3NhZ2VBdHRhY2htZW50fSBhdHRhY2htZW50IHRoZSBtZXRhZGF0YSB0byB1c2UgYXMgaGVhZGVyc1xuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIG91dHB1dCBpcyBmaW5pc2hlZFxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG91dHB1dERhdGEgPSAoYXR0YWNobWVudCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBvdXRwdXRCYXNlNjQoYXR0YWNobWVudC5lbmNvZGVkXG4gICAgICAgICAgICAgICAgPyAoX2EgPSBhdHRhY2htZW50LmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnXG4gICAgICAgICAgICAgICAgOiBCdWZmZXIuZnJvbSgoX2IgPSBhdHRhY2htZW50LmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKS50b1N0cmluZygnYmFzZTY0JyksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBvdXRwdXRcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvdXRwdXRUZXh0ID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gW107XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGU6JyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgQ1JMRiQxLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiA3Yml0JyxcbiAgICAgICAgICAgICAgICBDUkxGJDEsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChbJ0NvbnRlbnQtRGlzcG9zaXRpb246IGlubGluZScsIENSTEYkMSwgQ1JMRiQxXSk7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5jb25jYXQoW21lc3NhZ2UudGV4dCB8fCAnJywgQ1JMRiQxLCBDUkxGJDFdKTtcbiAgICAgICAgICAgIG91dHB1dChkYXRhLmpvaW4oJycpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7TWVzc2FnZUF0dGFjaG1lbnR9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gb3V0cHV0XG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgb3V0cHV0IGlzIGZpbmlzaGVkXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgb3V0cHV0UmVsYXRlZCA9IChtZXNzYWdlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm91bmRhcnkgPSBnZW5lcmF0ZUJvdW5kYXJ5KCk7XG4gICAgICAgICAgICBvdXRwdXQoYENvbnRlbnQtVHlwZTogbXVsdGlwYXJ0L3JlbGF0ZWQ7IGJvdW5kYXJ5PVwiJHtib3VuZGFyeX1cIiR7Q1JMRiQxfSR7Q1JMRiQxfS0tJHtib3VuZGFyeX0ke0NSTEYkMX1gKTtcbiAgICAgICAgICAgIG91dHB1dEF0dGFjaG1lbnQobWVzc2FnZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBvdXRwdXRNZXNzYWdlKGJvdW5kYXJ5LCAoX2EgPSBtZXNzYWdlLnJlbGF0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCAwLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dChgJHtDUkxGJDF9LS0ke2JvdW5kYXJ5fS0tJHtDUkxGJDF9JHtDUkxGJDF9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBvdXRwdXRcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciBvdXRwdXQgaXMgZmluaXNoZWRcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvdXRwdXRBbHRlcm5hdGl2ZSA9IChtZXNzYWdlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm91bmRhcnkgPSBnZW5lcmF0ZUJvdW5kYXJ5KCk7XG4gICAgICAgICAgICBvdXRwdXQoYENvbnRlbnQtVHlwZTogbXVsdGlwYXJ0L2FsdGVybmF0aXZlOyBib3VuZGFyeT1cIiR7Ym91bmRhcnl9XCIke0NSTEYkMX0ke0NSTEYkMX0tLSR7Ym91bmRhcnl9JHtDUkxGJDF9YCk7XG4gICAgICAgICAgICBvdXRwdXRUZXh0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgb3V0cHV0KGAtLSR7Ym91bmRhcnl9JHtDUkxGJDF9YCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBmaW5pc2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0KFtDUkxGJDEsICctLScsIGJvdW5kYXJ5LCAnLS0nLCBDUkxGJDEsIENSTEYkMV0uam9pbignJykpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYWx0ZXJuYXRpdmUucmVsYXRlZCkge1xuICAgICAgICAgICAgICAgIG91dHB1dFJlbGF0ZWQobWVzc2FnZS5hbHRlcm5hdGl2ZSwgZmluaXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dEF0dGFjaG1lbnQobWVzc2FnZS5hbHRlcm5hdGl2ZSwgZmluaXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xvc2UkMSA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCAoX2IgPSAoX2EgPSB0aGlzLmJ1ZmZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCd1dGYtOCcsIDAsIHRoaXMuYnVmZmVySW5kZXgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVySW5kZXggPSAwO1xuICAgICAgICAgICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3Jlc3VtZScpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3BhdXNlJyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG91dHB1dEhlYWRlckRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXNzYWdlLmF0dGFjaG1lbnRzLmxlbmd0aCB8fCB0aGlzLm1lc3NhZ2UuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQoYE1JTUUtVmVyc2lvbjogMS4wJHtDUkxGJDF9YCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0TWl4ZWQoKTtcbiAgICAgICAgICAgIH0gLy8geW91IG9ubHkgaGF2ZSBhIHRleHQgbWVzc2FnZSFcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFRleHQodGhpcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjbG9zZSQxKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG91dHB1dEhlYWRlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiB0aGlzLm1lc3NhZ2UuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IG91dHB1dCBCQ0MgaW4gdGhlIGhlYWRlcnMgKHJlZ2V4KSBub3IgY3VzdG9tIE9iamVjdC5wcm90b3R5cGUgZnVuY3Rpb25zLi4uXG4gICAgICAgICAgICAgICAgaWYgKCEvYmNjL2kudGVzdChoZWFkZXIpICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm1lc3NhZ2UuaGVhZGVyLCBoZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0RGFzaERlbGltaXRlZFRleHRUb1NuYWtlQ2FzZShoZWFkZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzogJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZS5oZWFkZXJbaGVhZGVyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIENSTEYkMSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0KGRhdGEuam9pbignJykpO1xuICAgICAgICAgICAgb3V0cHV0SGVhZGVyRGF0YSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoJ2Rlc3Ryb3knLCBjbG9zZSQxKTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhvdXRwdXRIZWFkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogcGF1c2UgdGhlIHN0cmVhbVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIHJlc3VtZSB0aGUgc3RyZWFtXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogZGVzdHJveSB0aGUgc3RyZWFtXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZXN0cm95JywgdGhpcy5idWZmZXJJbmRleCA+IDAgPyB7IG1lc3NhZ2U6ICdtZXNzYWdlIHN0cmVhbSBkZXN0cm95ZWQnIH0gOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIGRlc3Ryb3kgdGhlIHN0cmVhbSBhdCBmaXJzdCBvcHBvcnR1bml0eVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGRlc3Ryb3lTb29uKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bVxuICovXG5jb25zdCBTTVRQRXJyb3JTdGF0ZXMgPSB7XG4gICAgQ09VTEROT1RDT05ORUNUOiAxLFxuICAgIEJBRFJFU1BPTlNFOiAyLFxuICAgIEFVVEhGQUlMRUQ6IDMsXG4gICAgVElNRURPVVQ6IDQsXG4gICAgRVJST1I6IDUsXG4gICAgTk9DT05ORUNUSU9OOiA2LFxuICAgIEFVVEhOT1RTVVBQT1JURUQ6IDcsXG4gICAgQ09OTkVDVElPTkNMT1NFRDogOCxcbiAgICBDT05ORUNUSU9ORU5ERUQ6IDksXG4gICAgQ09OTkVDVElPTkFVVEg6IDEwLFxufTtcbmNsYXNzIFNNVFBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc210cCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29kZSBzbXRwIGVycm9yIHN0YXRlXG4gICAgICogQHBhcmFtIHtFcnJvciB8IG51bGx9IGVycm9yIHByZXZpb3VzIGVycm9yXG4gICAgICogQHBhcmFtIHt1bmtub3dufSBzbXRwIGFyYml0cmFyeSBkYXRhXG4gICAgICogQHJldHVybnMge1NNVFBFcnJvcn0gZXJyb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKG1lc3NhZ2UsIGNvZGUsIGVycm9yLCBzbXRwKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgPyBgJHttZXNzYWdlfSAoJHtlcnJvci5tZXNzYWdlfSlgIDogbWVzc2FnZTtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFNNVFBFcnJvcihtc2cpO1xuICAgICAgICBlcnIuY29kZSA9IGNvZGU7XG4gICAgICAgIGVyci5zbXRwID0gc210cDtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBlcnIucHJldmlvdXMgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbn1cblxuY2xhc3MgU01UUFJlc3BvbnNlTW9uaXRvciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtLCB0aW1lb3V0LCBvbmVycm9yKSB7XG4gICAgICAgIGxldCBidWZmZXIgPSAnJztcbiAgICAgICAgY29uc3Qgbm90aWZ5ID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgYnVmZmVyIGZvciByZXNwb25zZSBjb2Rlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBidWZmZXIucmVwbGFjZSgnXFxyJywgJycpO1xuICAgICAgICAgICAgICAgIGlmICghKChfYiA9IChfYSA9IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoL1xcbi8pXG4gICAgICAgICAgICAgICAgICAgIC5wb3AoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hdGNoKC9eKFxcZHszfSlcXHMvKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lID8gbGluZS5tYXRjaCgvKFxcZCspXFxzPyguKikvKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG1hdGNoICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8geyBjb2RlOiBtYXRjaFsxXSwgbWVzc2FnZTogbWF0Y2hbMl0sIGRhdGE6IGxpbmUgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgY29kZTogLTEsIGRhdGE6IGxpbmUgfTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgncmVzcG9uc2UnLCBudWxsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgncmVzcG9uc2UnLCBTTVRQRXJyb3IuY3JlYXRlKCdjb25uZWN0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yJywgU01UUEVycm9yU3RhdGVzLkVSUk9SLCBlcnIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGltZWRvdXQgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgncmVzcG9uc2UnLCBTTVRQRXJyb3IuY3JlYXRlKCd0aW1lZG91dCB3aGlsZSBjb25uZWN0aW5nIHRvIHNtdHAgc2VydmVyJywgU01UUEVycm9yU3RhdGVzLlRJTUVET1VULCBlcnIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd2F0Y2ggPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG5vdGlmeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbG9zZSA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdyZXNwb25zZScsIFNNVFBFcnJvci5jcmVhdGUoJ2Nvbm5lY3Rpb24gaGFzIGNsb3NlZCcsIFNNVFBFcnJvclN0YXRlcy5DT05ORUNUSU9OQ0xPU0VELCBlcnIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW5kID0gKGVycikgPT4ge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3BvbnNlJywgU01UUEVycm9yLmNyZWF0ZSgnY29ubmVjdGlvbiBoYXMgZW5kZWQnLCBTTVRQRXJyb3JTdGF0ZXMuQ09OTkVDVElPTkVOREVELCBlcnIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9wID0gKGVycikgPT4ge1xuICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygncmVzcG9uc2UnKTtcbiAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHdhdGNoKTtcbiAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgZW5kKTtcbiAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbG9zZSk7XG4gICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsICYmIHR5cGVvZiBvbmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCB3YXRjaCk7XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgZW5kKTtcbiAgICAgICAgc3RyZWFtLm9uKCdjbG9zZScsIGNsb3NlKTtcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgc3RyZWFtLnNldFRpbWVvdXQodGltZW91dCwgdGltZWRvdXQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtXG4gKi9cbmNvbnN0IEFVVEhfTUVUSE9EUyA9IHtcbiAgICBQTEFJTjogJ1BMQUlOJyxcbiAgICAnQ1JBTS1NRDUnOiAnQ1JBTS1NRDUnLFxuICAgIExPR0lOOiAnTE9HSU4nLFxuICAgIFhPQVVUSDI6ICdYT0FVVEgyJyxcbn07XG4vKipcbiAqIEByZWFkb25seVxuICogQGVudW1cbiAqL1xuY29uc3QgU01UUFN0YXRlID0ge1xuICAgIE5PVENPTk5FQ1RFRDogMCxcbiAgICBDT05ORUNUSU5HOiAxLFxuICAgIENPTk5FQ1RFRDogMixcbn07XG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSA1MDAwO1xuY29uc3QgU01UUF9QT1JUID0gMjU7XG5jb25zdCBTTVRQX1NTTF9QT1JUID0gNDY1O1xuY29uc3QgU01UUF9UTFNfUE9SVCA9IDU4NztcbmNvbnN0IENSTEYgPSAnXFxyXFxuJztcbmNvbnN0IEdSRVlMSVNUX0RFTEFZID0gMzAwO1xubGV0IERFQlVHID0gMDtcbi8qKlxuICogQHBhcmFtIHsuLi5hbnlbXX0gYXJncyB0aGUgbWVzc2FnZShzKSB0byBsb2dcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBsb2cgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmIChERUJVRyA9PT0gMSkge1xuICAgICAgICBhcmdzLmZvckVhY2goKGQpID0+IGNvbnNvbGUubG9nKHR5cGVvZiBkID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBkIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICA/IGQubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoZClcbiAgICAgICAgICAgIDogZCkpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55W10pOiB2b2lkfSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHsuLi5hbnlbXX0gYXJncyB0aGUgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGNhbGxlciA9IChjYWxsYmFjaywgLi4uYXJncykgPT4ge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgfVxufTtcbmNsYXNzIFNNVFBDb25uZWN0aW9uIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBTTVRQIGNsYXNzIHdyaXR0ZW4gdXNpbmcgcHl0aG9uJ3MgKDIuNykgc210cGxpYi5weSBhcyBhIGJhc2UuXG4gICAgICpcbiAgICAgKiBUbyB0YXJnZXQgYSBNZXNzYWdlIFRyYW5zZmVyIEFnZW50IChNVEEpLCBvbWl0IGFsbCBvcHRpb25zLlxuICAgICAqXG4gICAgICogTk9URTogYGhvc3RgIGlzIHRyaW1tZWQgYmVmb3JlIGJlaW5nIHVzZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbjsgaG93ZXZlciwgdGhlIG9yaWdpbmFsIHVudHJpbW1lZCB2YWx1ZSB3aWxsIHN0aWxsIGJlIHZpc2libGUgaW4gY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IHRpbWVvdXQsIGhvc3QsIHVzZXIsIHBhc3N3b3JkLCBkb21haW4sIHBvcnQsIHNzbCwgdGxzLCBsb2dnZXIsIGF1dGhlbnRpY2F0aW9uLCB9ID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVQ7XG4gICAgICAgIHRoaXMubG9nID0gbG9nO1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uID0gW1xuICAgICAgICAgICAgQVVUSF9NRVRIT0RTWydDUkFNLU1ENSddLFxuICAgICAgICAgICAgQVVUSF9NRVRIT0RTLkxPR0lOLFxuICAgICAgICAgICAgQVVUSF9NRVRIT0RTLlBMQUlOLFxuICAgICAgICAgICAgQVVUSF9NRVRIT0RTLlhPQVVUSDIsXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX3N0YXRlID0gU01UUFN0YXRlLk5PVENPTk5FQ1RFRDtcbiAgICAgICAgdGhpcy5fc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nZ2VkaW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zb2NrID0gbnVsbDtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tYWluID0gaG9zdG5hbWUoKTtcbiAgICAgICAgdGhpcy5ob3N0ID0gJ2xvY2FsaG9zdCc7XG4gICAgICAgIHRoaXMuc3NsID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGxzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ3JleWxpc3RSZXNwb25zZVRyYWNrZXIgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdXRoZW50aWNhdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRpb24gPSBhdXRoZW50aWNhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9tYWluID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5kb21haW4gPSBkb21haW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBob3N0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3NsICE9IG51bGwgJiZcbiAgICAgICAgICAgICh0eXBlb2Ygc3NsID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIHNzbCA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheShzc2wpID09PSBmYWxzZSkpKSB7XG4gICAgICAgICAgICB0aGlzLnNzbCA9IHNzbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGxzICE9IG51bGwgJiZcbiAgICAgICAgICAgICh0eXBlb2YgdGxzID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIHRscyA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSh0bHMpID09PSBmYWxzZSkpKSB7XG4gICAgICAgICAgICB0aGlzLnRscyA9IHRscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcnQgPSBwb3J0IHx8IChzc2wgPyBTTVRQX1NTTF9QT1JUIDogdGxzID8gU01UUF9UTFNfUE9SVCA6IFNNVFBfUE9SVCk7XG4gICAgICAgIHRoaXMubG9nZ2VkaW4gPSB1c2VyICYmIHBhc3N3b3JkID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICBpZiAoIXVzZXIgJiYgKChfYSA9IHBhc3N3b3JkID09PSBudWxsIHx8IHBhc3N3b3JkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXNzd29yZC5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcGFzc3dvcmRgIGNhbm5vdCBiZSBzZXQgd2l0aG91dCBgdXNlcmAnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWVwIHRoZXNlIHN0cmluZ3MgaGlkZGVuIHdoZW4gcXVpY2t5IGRlYnVnZ2luZy9sb2dnaW5nXG4gICAgICAgIHRoaXMudXNlciA9ICgpID0+IHVzZXI7XG4gICAgICAgIHRoaXMucGFzc3dvcmQgPSAoKSA9PiBwYXNzd29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2dnZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMubG9nID0gbG9nZ2VyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0gezAgfCAxfSBsZXZlbCAtXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZGVidWcobGV2ZWwpIHtcbiAgICAgICAgREVCVUcgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtTTVRQU3RhdGV9IHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICovXG4gICAgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgaW5zdGFuY2UgaXMgYXV0aG9yaXplZFxuICAgICAqL1xuICAgIGF1dGhvcml6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ2dlZGluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2ggYW4gU01UUCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogTk9URTogYGhvc3RgIGlzIHRyaW1tZWQgYmVmb3JlIGJlaW5nIHVzZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbjsgaG93ZXZlciwgdGhlIG9yaWdpbmFsIHVudHJpbW1lZCB2YWx1ZSB3aWxsIHN0aWxsIGJlIHZpc2libGUgaW4gY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueVtdKTogdm9pZH0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9ydF0gdGhlIHBvcnQgdG8gdXNlIGZvciB0aGUgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaG9zdF0gdGhlIGhvc3RuYW1lIHRvIHVzZSBmb3IgdGhlIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Nvbm5lY3RPcHRpb25zfSBbb3B0aW9ucz17fV0gdGhlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBjb25uZWN0KGNhbGxiYWNrLCBwb3J0ID0gdGhpcy5wb3J0LCBob3N0ID0gdGhpcy5ob3N0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zc2wgPSBvcHRpb25zLnNzbCB8fCB0aGlzLnNzbDtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBTTVRQU3RhdGUuTk9UQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICB0aGlzLnF1aXQoKCkgPT4gdGhpcy5jb25uZWN0KGNhbGxiYWNrLCBwb3J0LCBob3N0LCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coYGNvbm5lY3RlZDogJHt0aGlzLmhvc3R9OiR7dGhpcy5wb3J0fWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3NsICYmICF0aGlzLnRscykge1xuICAgICAgICAgICAgICAgIC8vIGlmIGtleS9jYS9jZXJ0IHdhcyBwYXNzZWQgaW4sIGNoZWNrIGlmIGNvbm5lY3Rpb24gaXMgYXV0aG9yaXplZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zc2wgIT09ICdib29sZWFuJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2sgaW5zdGFuY2VvZiBUTFNTb2NrZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuc29jay5hdXRob3JpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlcihjYWxsYmFjaywgU01UUEVycm9yLmNyZWF0ZSgnY291bGQgbm90IGVzdGFibGlzaCBhbiBzc2wgY29ubmVjdGlvbicsIFNNVFBFcnJvclN0YXRlcy5DT05ORUNUSU9OQVVUSCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgZXJyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY29ubmVjdGVkRXJyQmFjayA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKGVycik7XG4gICAgICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBTTVRQRXJyb3IuY3JlYXRlKCdjb3VsZCBub3QgY29ubmVjdCcsIFNNVFBFcnJvclN0YXRlcy5DT1VMRE5PVENPTk5FQ1QsIGVycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IChlcnIsIG1zZykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU01UUFN0YXRlLk5PVENPTk5FQ1RFRCAmJiAhdGhpcy5zb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBjYWxsZXIoY2FsbGJhY2ssIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtc2cuY29kZSA9PSAnMjIwJykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBtaWdodCBoYXBwZW4gZmlyc3QsIHNvIG5vIG5lZWQgdG8gd2FpdCBvbiBjb25uZWN0ZWQoKVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gU01UUFN0YXRlLkNPTk5FQ1RFRDtcbiAgICAgICAgICAgICAgICBjYWxsZXIoY2FsbGJhY2ssIG51bGwsIG1zZy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKGByZXNwb25zZSAoZGF0YSk6ICR7bXNnLmRhdGF9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWl0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBTTVRQRXJyb3IuY3JlYXRlKCdiYWQgcmVzcG9uc2Ugb24gY29ubmVjdGlvbicsIFNNVFBFcnJvclN0YXRlcy5CQURSRVNQT05TRSwgZXJyLCBtc2cuZGF0YSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFNNVFBTdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLmxvZyhgY29ubmVjdGluZzogJHt0aGlzLmhvc3R9OiR7dGhpcy5wb3J0fWApO1xuICAgICAgICBpZiAodGhpcy5zc2wpIHtcbiAgICAgICAgICAgIHRoaXMuc29jayA9IGNvbm5lY3QodGhpcy5wb3J0LCB0aGlzLmhvc3QudHJpbSgpLCB0eXBlb2YgdGhpcy5zc2wgPT09ICdvYmplY3QnID8gdGhpcy5zc2wgOiB7fSwgY29ubmVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc29jayA9IG5ldyBTb2NrZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc29jay5jb25uZWN0KHRoaXMucG9ydCwgdGhpcy5ob3N0LnRyaW0oKSwgY29ubmVjdGVkRXJyQmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb25pdG9yID0gbmV3IFNNVFBSZXNwb25zZU1vbml0b3IodGhpcy5zb2NrLCB0aGlzLnRpbWVvdXQsICgpID0+IHRoaXMuY2xvc2UodHJ1ZSkpO1xuICAgICAgICB0aGlzLnNvY2sub25jZSgncmVzcG9uc2UnLCByZXNwb25zZSk7XG4gICAgICAgIHRoaXMuc29jay5vbmNlKCdlcnJvcicsIHJlc3BvbnNlKTsgLy8gdGhlIHNvY2tldCBjb3VsZCByZXNldCBvciB0aHJvdywgc28gbGV0J3MgaGFuZGxlIGl0IGFuZCBsZXQgdGhlIHVzZXIga25vd1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueVtdKTogdm9pZH0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciByZXNwb25zZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHNlbmQoc3RyLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zb2NrICE9IG51bGwgJiYgdGhpcy5fc3RhdGUgPT09IFNNVFBTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKHN0cik7XG4gICAgICAgICAgICB0aGlzLnNvY2sub25jZSgncmVzcG9uc2UnLCAoZXJyLCBtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlcihjYWxsYmFjaywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBudWxsLCBtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuc29jay53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29jay53cml0ZShzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSh0cnVlKTtcbiAgICAgICAgICAgIGNhbGxlcihjYWxsYmFjaywgU01UUEVycm9yLmNyZWF0ZSgnbm8gY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZCcsIFNNVFBFcnJvclN0YXRlcy5OT0NPTk5FQ1RJT04pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNtZCBjb21tYW5kIHRvIGlzc3VlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnlbXSk6IHZvaWR9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0geyhudW1iZXJbXSB8IG51bWJlcil9IFtjb2Rlcz1bMjUwXV0gYXJyYXkgY29kZXNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBjb21tYW5kKGNtZCwgY2FsbGJhY2ssIGNvZGVzID0gWzI1MF0pIHtcbiAgICAgICAgY29uc3QgY29kZXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29kZXMpXG4gICAgICAgICAgICA/IGNvZGVzXG4gICAgICAgICAgICA6IHR5cGVvZiBjb2RlcyA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IFtjb2Rlc11cbiAgICAgICAgICAgICAgICA6IFsyNTBdO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IChlcnIsIG1zZykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxlcihjYWxsYmFjaywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIobXNnLmNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rlc0FycmF5LmluZGV4T2YoY29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlcihjYWxsYmFjaywgZXJyLCBtc2cuZGF0YSwgbXNnLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoY29kZSA9PT0gNDUwIHx8IGNvZGUgPT09IDQ1MSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZ3JleWxpc3QnKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyZXlsaXN0UmVzcG9uc2VUcmFja2VyLmhhcyhyZXNwb25zZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JleWxpc3RSZXNwb25zZVRyYWNrZXIuYWRkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQoY21kICsgQ1JMRiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LCBHUkVZTElTVF9ERUxBWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXggPSBtc2cubWVzc2FnZSA/IGA6ICR7bXNnLm1lc3NhZ2V9YCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgYmFkIHJlc3BvbnNlIG9uIGNvbW1hbmQgJyR7Y21kLnNwbGl0KCcgJylbMF19JyR7c3VmZml4fWA7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlcihjYWxsYmFjaywgU01UUEVycm9yLmNyZWF0ZShlcnJvck1lc3NhZ2UsIFNNVFBFcnJvclN0YXRlcy5CQURSRVNQT05TRSwgbnVsbCwgbXNnLmRhdGEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ3JleWxpc3RSZXNwb25zZVRyYWNrZXIuZGVsZXRlKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5zZW5kKGNtZCArIENSTEYsIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBkZXNjcmlwdGlvbiBTTVRQICdoZWxvJyBjb21tYW5kLlxuICAgICAqXG4gICAgICogSG9zdG5hbWUgdG8gc2VuZCBmb3Igc2VsZiBjb21tYW5kIGRlZmF1bHRzIHRvIHRoZSBGUUROIG9mIHRoZSBsb2NhbFxuICAgICAqIGhvc3QuXG4gICAgICpcbiAgICAgKiBBcyB0aGlzIGNvbW1hbmQgd2FzIGRlcHJlY2F0ZWQgYnkgcmZjMjgyMSwgaXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1jb21wbGlhbnQgc2VydmVycy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIxI2FwcGVuZGl4LUYuM1xuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnlbXSk6IHZvaWR9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluIHRoZSBkb21haW4gdG8gYXNzb2NpYXRlIHdpdGggdGhlICdoZWxvJyByZXF1ZXN0XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgaGVsbyhjYWxsYmFjaywgZG9tYWluKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZChgaGVsbyAke2RvbWFpbiB8fCB0aGlzLmRvbWFpbn1gLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZV9zbXRwX2ZlYXR1cmVzKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNhbGxlcihjYWxsYmFjaywgZXJyLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueVtdKTogdm9pZH0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciByZXNwb25zZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHN0YXJ0dGxzKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGVyciwgbXNnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bGwgc29ja2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gJyB3aGlsZSBlc3RhYmxpc2hpbmcgYSBzdGFydHRscyBzZXNzaW9uJztcbiAgICAgICAgICAgICAgICBjYWxsZXIoY2FsbGJhY2ssIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN1cmVDb250ZXh0ID0gY3JlYXRlU2VjdXJlQ29udGV4dCh0eXBlb2YgdGhpcy50bHMgPT09ICdvYmplY3QnID8gdGhpcy50bHMgOiB7fSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdXJlU29ja2V0ID0gbmV3IFRMU1NvY2tldCh0aGlzLnNvY2ssIHsgc2VjdXJlQ29udGV4dCB9KTtcbiAgICAgICAgICAgICAgICBzZWN1cmVTb2NrZXQub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsZXIoY2FsbGJhY2ssIGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2sgPSBzZWN1cmVTb2NrZXQ7XG4gICAgICAgICAgICAgICAgbmV3IFNNVFBSZXNwb25zZU1vbml0b3IodGhpcy5zb2NrLCB0aGlzLnRpbWVvdXQsICgpID0+IHRoaXMuY2xvc2UodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGNhbGxlcihjYWxsYmFjaywgbXNnLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbW1hbmQoJ3N0YXJ0dGxzJywgcmVzcG9uc2UsIFsyMjBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIHRoZSBzdHJpbmcgdG8gcGFyc2UgZm9yIGZlYXR1cmVzXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgcGFyc2Vfc210cF9mZWF0dXJlcyhkYXRhKSB7XG4gICAgICAgIC8vICBBY2NvcmRpbmcgdG8gUkZDMTg2OSBzb21lIChiYWRseSB3cml0dGVuKVxuICAgICAgICAvLyAgTVRBJ3Mgd2lsbCBkaXNjb25uZWN0IG9uIGFuIGVobG8uIFRvc3MgYW4gZXhjZXB0aW9uIGlmXG4gICAgICAgIC8vICB0aGF0IGhhcHBlbnMgLWRkbVxuICAgICAgICBkYXRhLnNwbGl0KCdcXG4nKS5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlID0gZXh0Lm1hdGNoKC9eKD86XFxkK1stPV0/KVxccyo/KFteXFxzXSspKD86XFxzKyguKilcXHMqPyk/JC8pO1xuICAgICAgICAgICAgLy8gVG8gYmUgYWJsZSB0byBjb21tdW5pY2F0ZSB3aXRoIGFzIG1hbnkgU01UUCBzZXJ2ZXJzIGFzIHBvc3NpYmxlLFxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byB0YWtlIHRoZSBvbGQtc3R5bGUgYXV0aCBhZHZlcnRpc2VtZW50IGludG8gYWNjb3VudCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2U6XG4gICAgICAgICAgICAvLyAxKSBFbHNlIG91ciBTTVRQIGZlYXR1cmUgcGFyc2VyIGdldHMgY29uZnVzZWQuXG4gICAgICAgICAgICAvLyAyKSBUaGVyZSBhcmUgc29tZSBzZXJ2ZXJzIHRoYXQgb25seSBhZHZlcnRpc2UgdGhlIGF1dGggbWV0aG9kcyB3ZVxuICAgICAgICAgICAgLy8gc3VwcG9ydCB1c2luZyB0aGUgb2xkIHN0eWxlLlxuICAgICAgICAgICAgaWYgKHBhcnNlICE9IG51bGwgJiYgdGhpcy5mZWF0dXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gUkZDIDE4NjkgcmVxdWlyZXMgYSBzcGFjZSBiZXR3ZWVuIGVobG8ga2V5d29yZCBhbmQgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIGFjdHVhbGx5IHN0cmljdGVyLCBpbiB0aGF0IG9ubHkgc3BhY2VzIGFyZSBhbGxvd2VkIGJldHdlZW5cbiAgICAgICAgICAgICAgICAvLyBwYXJhbWV0ZXJzLCBidXQgd2VyZSBub3QgZ29pbmcgdG8gY2hlY2sgZm9yIHRoYXQgaGVyZS4gIE5vdGVcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZSBzcGFjZSBpc24ndCBwcmVzZW50IGlmIHRoZXJlIGFyZSBubyBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNbcGFyc2VbMV0udG9Mb3dlckNhc2UoKV0gPSBwYXJzZVsyXSB8fCB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55W10pOiB2b2lkfSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpbiB0aGUgZG9tYWluIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSAnZWhsbycgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGVobG8oY2FsbGJhY2ssIGRvbWFpbikge1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0ge307XG4gICAgICAgIHRoaXMuY29tbWFuZChgZWhsbyAke2RvbWFpbiB8fCB0aGlzLmRvbWFpbn1gLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZV9zbXRwX2ZlYXR1cmVzKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRscyAmJiAhdGhpcy5fc2VjdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnR0bHMoKCkgPT4gdGhpcy5laGxvKGNhbGxiYWNrLCBkb21haW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlcihjYWxsYmFjaywgZXJyLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdCB0aGUgZmVhdHVyZXMga2V5bmFtZSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBleHRlbnNpb24gZXhpc3RzXG4gICAgICovXG4gICAgaGFzX2V4dG4ob3B0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmZlYXR1cmVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSlbb3B0LnRvTG93ZXJDYXNlKCldID09PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZGVzY3JpcHRpb24gU01UUCAnaGVscCcgY29tbWFuZCwgcmV0dXJucyB0ZXh0IGZyb20gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55W10pOiB2b2lkfSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpbiB0aGUgZG9tYWluIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSAnaGVscCcgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGhlbHAoY2FsbGJhY2ssIGRvbWFpbikge1xuICAgICAgICB0aGlzLmNvbW1hbmQoZG9tYWluID8gYGhlbHAgJHtkb21haW59YCA6ICdoZWxwJywgY2FsbGJhY2ssIFsyMTEsIDIxNF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnlbXSk6IHZvaWR9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICByc2V0KGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZCgncnNldCcsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55W10pOiB2b2lkfSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIHJlc3BvbnNlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgbm9vcChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnNlbmQoJ25vb3AnLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueVtdKTogdm9pZH0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tIHRoZSBzZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBtYWlsKGNhbGxiYWNrLCBmcm9tKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZChgbWFpbCBGUk9NOiR7ZnJvbX1gLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueVtdKTogdm9pZH0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0byB0aGUgcmVjZWl2ZXJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICByY3B0KGNhbGxiYWNrLCB0bykge1xuICAgICAgICB0aGlzLmNvbW1hbmQoYFJDUFQgVE86JHt0b31gLCBjYWxsYmFjaywgWzI1MCwgMjUxXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueVtdKTogdm9pZH0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciByZXNwb25zZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGRhdGEoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jb21tYW5kKCdkYXRhJywgY2FsbGJhY2ssIFszNTRdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55W10pOiB2b2lkfSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIHJlc3BvbnNlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZGF0YV9lbmQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jb21tYW5kKGAke0NSTEZ9LmAsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIHRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBtZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5sb2coZGF0YSk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuc29jaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndyaXRlKGRhdGEpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmxvZygnbm8gc29ja2V0IHRvIHdyaXRlIHRvJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZGVzY3JpcHRpb24gU01UUCAndmVyaWZ5JyBjb21tYW5kIC0tIGNoZWNrcyBmb3IgYWRkcmVzcyB2YWxpZGl0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyB0aGUgYWRkcmVzcyB0byB2YWxpZGF0ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55W10pOiB2b2lkfSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIHJlc3BvbnNlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdmVyaWZ5KGFkZHJlc3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZChgdnJmeSAke2FkZHJlc3N9YCwgY2FsbGJhY2ssIFsyNTAsIDI1MSwgMjUyXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZGVzY3JpcHRpb24gU01UUCAnZXhwbicgY29tbWFuZCAtLSBleHBhbmRzIGEgbWFpbGluZyBsaXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIHRoZSBtYWlsaW5nIGxpc3QgdG8gZXhwYW5kXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnlbXSk6IHZvaWR9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBleHBuKGFkZHJlc3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZChgZXhwbiAke2FkZHJlc3N9YCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxzIHRoaXMuZWhsbygpIGFuZCwgaWYgYW4gZXJyb3Igb2NjdXJzLCB0aGlzLmhlbG8oKS5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGhhcyBiZWVuIG5vIHByZXZpb3VzIEVITE8gb3IgSEVMTyBjb21tYW5kIHNlbGYgc2Vzc2lvbiwgc2VsZlxuICAgICAqIG1ldGhvZCB0cmllcyBFU01UUCBFSExPIGZpcnN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnlbXSk6IHZvaWR9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RvbWFpbl0gdGhlIGRvbWFpbiB0byBhc3NvY2lhdGUgd2l0aCB0aGUgY29tbWFuZFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGVobG9fb3JfaGVsb19pZl9uZWVkZWQoY2FsbGJhY2ssIGRvbWFpbikge1xuICAgICAgICAvLyBpcyB0aGlzIGNvZGUgY2FsbGFibGUuLi4/XG4gICAgICAgIGlmICghdGhpcy5mZWF0dXJlcykge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoZXJyLCBkYXRhKSA9PiBjYWxsZXIoY2FsbGJhY2ssIGVyciwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmVobG8oKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWxvKHJlc3BvbnNlLCBkb21haW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBlcnIsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGRvbWFpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqXG4gICAgICogTG9nIGluIG9uIGFuIFNNVFAgc2VydmVyIHRoYXQgcmVxdWlyZXMgYXV0aGVudGljYXRpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBoYXMgYmVlbiBubyBwcmV2aW91cyBFSExPIG9yIEhFTE8gY29tbWFuZCBzZWxmIHNlc3Npb24sIHNlbGZcbiAgICAgKiBtZXRob2QgdHJpZXMgRVNNVFAgRUhMTyBmaXJzdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIG5vcm1hbGx5IGlmIHRoZSBhdXRoZW50aWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55W10pOiB2b2lkfSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VyXSB0aGUgdXNlcm5hbWUgdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Bhc3N3b3JkXSB0aGUgcGFzc3dvcmQgZm9yIHRoZSBhdXRoZW50aWNhdGlvblxuICAgICAqIEBwYXJhbSB7eyBtZXRob2Q6IHN0cmluZywgZG9tYWluOiBzdHJpbmcgfX0gW29wdGlvbnNdIGxvZ2luIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBsb2dpbihjYWxsYmFjaywgdXNlciwgcGFzc3dvcmQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBsb2dpbiA9IHtcbiAgICAgICAgICAgIHVzZXI6IHVzZXIgPyAoKSA9PiB1c2VyIDogdGhpcy51c2VyLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkID8gKCkgPT4gcGFzc3dvcmQgOiB0aGlzLnBhc3N3b3JkLFxuICAgICAgICAgICAgbWV0aG9kOiAoX2IgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWV0aG9kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9VcHBlckNhc2UoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG9tYWluKSB8fCB0aGlzLmRvbWFpbjtcbiAgICAgICAgY29uc3QgaW5pdGlhdGUgPSAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbGxlbmdlIGNoYWxsZW5nZVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gYmFzZTY0IGNyYW0gaGFzaFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVDcmFtTWQ1ID0gKGNoYWxsZW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhtYWMgPSBjcmVhdGVIbWFjKCdtZDUnLCBsb2dpbi5wYXNzd29yZCgpKTtcbiAgICAgICAgICAgICAgICBobWFjLnVwZGF0ZShCdWZmZXIuZnJvbShjaGFsbGVuZ2UsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGAke2xvZ2luLnVzZXIoKX0gJHtobWFjLmRpZ2VzdCgnaGV4Jyl9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gYmFzZTY0IGxvZ2luL3Bhc3N3b3JkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGVuY29kZVBsYWluID0gKCkgPT4gQnVmZmVyLmZyb20oYFxcdTAwMDAke2xvZ2luLnVzZXIoKX1cXHUwMDAwJHtsb2dpbi5wYXNzd29yZCgpfWApLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9nbWFpbC94b2F1dGgyX3Byb3RvY29sXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBiYXNlNjQgeG9hdXRoMiBhdXRoIHRva2VuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGVuY29kZVhvYXV0aDIgPSAoKSA9PiBCdWZmZXIuZnJvbShgdXNlcj0ke2xvZ2luLnVzZXIoKX1cXHUwMDAxYXV0aD1CZWFyZXIgJHtsb2dpbi5wYXNzd29yZCgpfVxcdTAwMDFcXHUwMDAxYCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgLy8gTGlzdCBvZiBhdXRoZW50aWNhdGlvbiBtZXRob2RzIHdlIHN1cHBvcnQ6IGZyb20gcHJlZmVycmVkIHRvXG4gICAgICAgICAgICAvLyBsZXNzIHByZWZlcnJlZCBtZXRob2RzLlxuICAgICAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmZXJyZWQgPSB0aGlzLmF1dGhlbnRpY2F0aW9uO1xuICAgICAgICAgICAgICAgIGxldCBhdXRoID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoKF9hID0gdGhpcy5mZWF0dXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWydhdXRoJ10pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhdXRoID0gdGhpcy5mZWF0dXJlc1snYXV0aCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZlcnJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXV0aC5pbmNsdWRlcyhwcmVmZXJyZWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBwcmVmZXJyZWRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogaGFuZGxlIGJhZCByZXNwb25zZXMgZnJvbSBjb21tYW5kIGRpZmZlcmVudGx5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgZXJyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3Vua25vd259IGRhdGEgZGF0YVxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGZhaWxlZCA9IChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlZGluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpOyAvLyBpZiBhdXRoIGlzIGJhZCwgY2xvc2UgdGhlIGNvbm5lY3Rpb24sIGl0IHdvbid0IGdldCBiZXR0ZXIgYnkgaXRzZWxmXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKHRoaXMucGFzc3dvcmQoKSwgJ1JFREFDVEVEJyk7XG4gICAgICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBTTVRQRXJyb3IuY3JlYXRlKCdhdXRob3JpemF0aW9uLmZhaWxlZCcsIFNNVFBFcnJvclN0YXRlcy5BVVRIRkFJTEVELCBlcnIsIGRhdGEpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciBlcnJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YSBkYXRhXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBmYWlsZWQoZXJyLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VkaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjYWxsZXIoY2FsbGJhY2ssIGVyciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyIGVyclxuICAgICAgICAgICAgICogQHBhcmFtIHt1bmtub3dufSBkYXRhIGRhdGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgbXNnXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdCA9IChlcnIsIGRhdGEsIG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkKGVyciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBBVVRIX01FVEhPRFNbJ0NSQU0tTUQ1J10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZChlbmNvZGVDcmFtTWQ1KG1zZyksIHJlc3BvbnNlLCBbMjM1LCA1MDNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09IEFVVEhfTUVUSE9EUy5MT0dJTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kKEJ1ZmZlci5mcm9tKGxvZ2luLnBhc3N3b3JkKCkpLnRvU3RyaW5nKCdiYXNlNjQnKSwgcmVzcG9uc2UsIFsyMzUsIDUwM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyIGVyclxuICAgICAgICAgICAgICogQHBhcmFtIHt1bmtub3dufSBkYXRhIGRhdGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgbXNnXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdFVzZXIgPSAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBmYWlsZWQoZXJyLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IEFVVEhfTUVUSE9EUy5MT0dJTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kKEJ1ZmZlci5mcm9tKGxvZ2luLnVzZXIoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpLCBhdHRlbXB0LCBbMzM0XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEFVVEhfTUVUSE9EU1snQ1JBTS1NRDUnXTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kKGBBVVRIICAke0FVVEhfTUVUSE9EU1snQ1JBTS1NRDUnXX1gLCBhdHRlbXB0LCBbMzM0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQVVUSF9NRVRIT0RTLkxPR0lOOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmQoYEFVVEggJHtBVVRIX01FVEhPRFMuTE9HSU59YCwgYXR0ZW1wdFVzZXIsIFszMzRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBVVRIX01FVEhPRFMuUExBSU46XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZChgQVVUSCAke0FVVEhfTUVUSE9EUy5QTEFJTn0gJHtlbmNvZGVQbGFpbigpfWAsIHJlc3BvbnNlLCBbMjM1LCA1MDNdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBVVRIX01FVEhPRFMuWE9BVVRIMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kKGBBVVRIICR7QVVUSF9NRVRIT0RTLlhPQVVUSDJ9ICR7ZW5jb2RlWG9hdXRoMigpfWAsIHJlc3BvbnNlLCBbMjM1LCA1MDNdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBTTVRQRXJyb3IuY3JlYXRlKCdubyBmb3JtIG9mIGF1dGhvcml6YXRpb24gc3VwcG9ydGVkJywgU01UUEVycm9yU3RhdGVzLkFVVEhOT1RTVVBQT1JURUQsIG51bGwsIGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZWhsb19vcl9oZWxvX2lmX25lZWRlZChpbml0aWF0ZSwgZG9tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBmb3JjZSBkZXN0cm95IHRoZSBjb25uZWN0aW9uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgY2xvc2UoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5zb2NrKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnc210cCBjb25uZWN0aW9uIGRlc3Ryb3llZCEnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2suZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ3NtdHAgY29ubmVjdGlvbiBjbG9zZWQuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vbml0b3IpIHtcbiAgICAgICAgICAgIHRoaXMubW9uaXRvci5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLm1vbml0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlID0gU01UUFN0YXRlLk5PVENPTk5FQ1RFRDtcbiAgICAgICAgdGhpcy5fc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc29jayA9IG51bGw7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmxvZ2dlZGluID0gISh0aGlzLnVzZXIoKSAmJiB0aGlzLnBhc3N3b3JkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnlbXSk6IHZvaWR9IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gY2FsbCBhZnRlciByZXNwb25zZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHF1aXQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jb21tYW5kKCdxdWl0JywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgY2FsbGVyKGNhbGxiYWNrLCBlcnIsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9LCBbMjIxLCAyNTBdKTtcbiAgICB9XG59XG5cbmNsYXNzIFNNVFBDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHN0YW5kYXJkIFNNVFAgY2xpZW50IGJhY2tlZCBieSBhIHNlbGYtbWFuYWdlZCBTTVRQIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBOT1RFOiBgaG9zdGAgaXMgdHJpbW1lZCBiZWZvcmUgYmVpbmcgdXNlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uOyBob3dldmVyLCB0aGUgb3JpZ2luYWwgdW50cmltbWVkIHZhbHVlIHdpbGwgc3RpbGwgYmUgdmlzaWJsZSBpbiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTTVRQQ29ubmVjdGlvbk9wdGlvbnN9IHNlcnZlciBzbXRwIG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnNlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zbXRwID0gbmV3IFNNVFBDb25uZWN0aW9uKHNlcnZlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGVtcGxhdGUge01lc3NhZ2UgfCBNZXNzYWdlSGVhZGVyc30gVFxuICAgICAqIEBwYXJhbSB7VH0gbXNnIHRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VDYWxsYmFjazxUPn0gY2FsbGJhY2sgcmVjZWl2ZXIgZm9yIHRoZSBlcnJvciAoaWYgYW55KSBhcyB3ZWxsIGFzIHRoZSBwYXNzZWQtaW4gbWVzc2FnZSAvIGhlYWRlcnNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzZW5kKG1zZywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1zZyBpbnN0YW5jZW9mIE1lc3NhZ2VcbiAgICAgICAgICAgID8gbXNnXG4gICAgICAgICAgICA6IHRoaXMuX2Nhbk1ha2VNZXNzYWdlKG1zZylcbiAgICAgICAgICAgICAgICA/IG5ldyBNZXNzYWdlKG1zZylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignbWVzc2FnZSBpcyBub3QgYSB2YWxpZCBNZXNzYWdlIGluc3RhbmNlJyksIG1zZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWxpZGF0aW9uRXJyb3IgfSA9IG1lc3NhZ2UuY2hlY2tWYWxpZGl0eSgpO1xuICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmNyZWF0ZU1lc3NhZ2VTdGFjayhtZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoc3RhY2sudG8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignTm8gcmVjaXBpZW50cyBmb3VuZCBpbiBtZXNzYWdlJyksIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgdGhpcy5fcG9sbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKHZhbGlkYXRpb25FcnJvciksIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0ZW1wbGF0ZSB7TWVzc2FnZSB8IE1lc3NhZ2VIZWFkZXJzfSBUXG4gICAgICogQHBhcmFtIHtUfSBtc2cgdGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fSBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcGFzc2VkLWluIG1lc3NhZ2UgLyBoZWFkZXJzXG4gICAgICovXG4gICAgc2VuZEFzeW5jKG1zZykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZW5kKG1zZywgKGVyciwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZm9ydHVuYXRlbHksIHRoZSBjb25kaXRpb25hbCB0eXBlIGRvZXNuJ3QgcmVhY2ggaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3J0dW5hdGVseSwgd2Ugb25seSByZXR1cm4gYSBgTWVzc2FnZWAgd2hlbiBlcnIgaXMgbnVsbCwgc28gdGhpcyBpcyBzYWZlXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIGEgbWVzc2FnZSB0byB0aGUgcmF3IG9iamVjdCB1c2VkIGJ5IHRoZSBpbnRlcm5hbCBzdGFjay5cbiAgICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgbWVzc2FnZSB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIHtNZXNzYWdlQ2FsbGJhY2t9IGNhbGxiYWNrIGVycmJhY2tcbiAgICAgKiBAcmV0dXJucyB7TWVzc2FnZVN0YWNrfSByYXcgbWVzc2FnZSBvYmplY3RcbiAgICAgKi9cbiAgICBjcmVhdGVNZXNzYWdlU3RhY2sobWVzc2FnZSwgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIMO4ICovXG4gICAgfSkge1xuICAgICAgICBjb25zdCBbeyBhZGRyZXNzOiBmcm9tIH1dID0gYWRkcmVzc3BhcnNlcihtZXNzYWdlLmhlYWRlci5mcm9tKTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdG86IFtdLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGhlYWRlcjogeyB0bywgY2MsIGJjYywgJ3JldHVybi1wYXRoJzogcmV0dXJuUGF0aCB9LCB9ID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKCh0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkodG8pKSAmJiB0by5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGFjay50byA9IGFkZHJlc3NwYXJzZXIodG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodHlwZW9mIGNjID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGNjKSkgJiYgY2MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhY2sudG8gPSBzdGFjay50by5jb25jYXQoYWRkcmVzc3BhcnNlcihjYykuZmlsdGVyKCh4KSA9PiBzdGFjay50by5zb21lKCh5KSA9PiB5LmFkZHJlc3MgPT09IHguYWRkcmVzcykgPT09IGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2YgYmNjID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGJjYykpICYmIGJjYy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGFjay50byA9IHN0YWNrLnRvLmNvbmNhdChhZGRyZXNzcGFyc2VyKGJjYykuZmlsdGVyKCh4KSA9PiBzdGFjay50by5zb21lKCh5KSA9PiB5LmFkZHJlc3MgPT09IHguYWRkcmVzcykgPT09IGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXR1cm5QYXRoID09PSAnc3RyaW5nJyAmJiByZXR1cm5QYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVyblBhdGggPSBhZGRyZXNzcGFyc2VyKHJldHVyblBhdGgpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZFJldHVyblBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt7IGFkZHJlc3M6IHJldHVyblBhdGhBZGRyZXNzIH1dID0gcGFyc2VkUmV0dXJuUGF0aDtcbiAgICAgICAgICAgICAgICBzdGFjay5yZXR1cm5QYXRoID0gcmV0dXJuUGF0aEFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX3BvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNtdHAuc3RhdGUoKSA9PSBTTVRQU3RhdGUuTk9UQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdCh0aGlzLnF1ZXVlWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc210cC5zdGF0ZSgpID09IFNNVFBTdGF0ZS5DT05ORUNURUQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5zZW5kaW5nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRtYWlsKHRoaXMucXVldWUuc2hpZnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2FpdCBhcm91bmQgMSBzZWNvbmRzIGluIGNhc2Ugc29tZXRoaW5nIGRvZXMgY29tZSBpbixcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNsb3NlIG91dCBTTVRQIGNvbm5lY3Rpb24gaWYgc3RpbGwgb3BlblxuICAgICAgICBlbHNlIGlmICh0aGlzLnNtdHAuc3RhdGUoKSA9PSBTTVRQU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNtdHAucXVpdCgpLCAxMDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtNZXNzYWdlU3RhY2t9IHN0YWNrIHN0YWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX2Nvbm5lY3Qoc3RhY2spIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciBjYWxsYmFjayBlcnJvclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNvbm5lY3QgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZ2luID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5jYWxsYmFjayhlcnIsIHN0YWNrLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgb3V0IHRoZSBxdWV1ZSBzbyBhbGwgY2FsbGJhY2tzIGNhbiBiZSBjYWxsZWQgd2l0aCB0aGUgc2FtZSBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zbXRwLmF1dGhvcml6ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNtdHAubG9naW4oYmVnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbXRwLmVobG9fb3JfaGVsb19pZl9uZWVkZWQoYmVnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLmNhbGxiYWNrKGVyciwgc3RhY2subWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgb3V0IHRoZSBxdWV1ZSBzbyBhbGwgY2FsbGJhY2tzIGNhbiBiZSBjYWxsZWQgd2l0aCB0aGUgc2FtZSBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNtdHAuY29ubmVjdChjb25uZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7TWVzc2FnZVN0YWNrfSBtc2cgbWVzc2FnZSBzdGFja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBjYW4gbWFrZSBtZXNzYWdlXG4gICAgICovXG4gICAgX2Nhbk1ha2VNZXNzYWdlKG1zZykge1xuICAgICAgICByZXR1cm4gKG1zZy5mcm9tICYmXG4gICAgICAgICAgICAobXNnLnRvIHx8IG1zZy5jYyB8fCBtc2cuYmNjKSAmJlxuICAgICAgICAgICAgKG1zZy50ZXh0ICE9PSB1bmRlZmluZWQgfHwgdGhpcy5fY29udGFpbnNJbmxpbmVkSHRtbChtc2cuYXR0YWNobWVudCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7TWVzc2FnZUF0dGFjaG1lbnQgfCBNZXNzYWdlQXR0YWNobWVudFtdfSBhdHRhY2htZW50IGF0dGFjaG1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgYXR0YWNobWVudCBjb250YWlucyBpbmxpbmVkIGh0bWxcbiAgICAgKi9cbiAgICBfY29udGFpbnNJbmxpbmVkSHRtbChhdHRhY2htZW50KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dGFjaG1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXR0YWNobWVudC5zb21lKChhdHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNBdHRhY2htZW50SW5saW5lZEh0bWwoYXR0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzQXR0YWNobWVudElubGluZWRIdG1sKGF0dGFjaG1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VBdHRhY2htZW50fSBhdHRhY2htZW50IGF0dGFjaG1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgYXR0YWNobWVudCBpcyBpbmxpbmVkIGh0bWxcbiAgICAgKi9cbiAgICBfaXNBdHRhY2htZW50SW5saW5lZEh0bWwoYXR0YWNobWVudCkge1xuICAgICAgICByZXR1cm4gKGF0dGFjaG1lbnQgJiZcbiAgICAgICAgICAgIChhdHRhY2htZW50LmRhdGEgfHwgYXR0YWNobWVudC5wYXRoKSAmJlxuICAgICAgICAgICAgYXR0YWNobWVudC5hbHRlcm5hdGl2ZSA9PT0gdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VTdGFja30gc3RhY2sgc3RhY2tcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE1lc3NhZ2VTdGFjayk6IHZvaWR9IG5leHQgbmV4dFxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihFcnJvcik6IHZvaWR9IGNhbGxiYWNrXG4gICAgICovXG4gICAgX3NlbmRzbXRwKHN0YWNrLCBuZXh0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBbZXJyXSBlcnJvclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVyciAmJiBuZXh0KSB7XG4gICAgICAgICAgICAgICAgbmV4dC5hcHBseSh0aGlzLCBbc3RhY2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIHNuYWcgb24gU01UUCBjb21tYW5kcywgY2FsbCBkb25lLCBwYXNzaW5nIHRoZSBlcnJvclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBmaXJzdCByZXNldCBTTVRQIHN0YXRlIHNvIHF1ZXVlIGNhbiBjb250aW51ZSBwb2xsaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5zbXRwLnJzZXQoKCkgPT4gdGhpcy5fc2VuZGRvbmUoZXJyLCBzdGFjaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtNZXNzYWdlU3RhY2t9IHN0YWNrIHN0YWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX3NlbmRtYWlsKHN0YWNrKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBzdGFjay5yZXR1cm5QYXRoIHx8IHN0YWNrLmZyb207XG4gICAgICAgIHRoaXMuc2VuZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc210cC5tYWlsKHRoaXMuX3NlbmRzbXRwKHN0YWNrLCB0aGlzLl9zZW5kcmNwdCksICc8JyArIGZyb20gKyAnPicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtNZXNzYWdlU3RhY2t9IHN0YWNrIHN0YWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX3NlbmRyY3B0KHN0YWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHN0YWNrLnRvID09IG51bGwgfHwgdHlwZW9mIHN0YWNrLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RhY2sudG8gbXVzdCBiZSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvID0gKF9hID0gc3RhY2sudG8uc2hpZnQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZHJlc3M7XG4gICAgICAgIHRoaXMuc210cC5yY3B0KHRoaXMuX3NlbmRzbXRwKHN0YWNrLCBzdGFjay50by5sZW5ndGggPyB0aGlzLl9zZW5kcmNwdCA6IHRoaXMuX3NlbmRkYXRhKSwgYDwke3RvfT5gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7TWVzc2FnZVN0YWNrfSBzdGFjayBzdGFja1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIF9zZW5kZGF0YShzdGFjaykge1xuICAgICAgICB0aGlzLnNtdHAuZGF0YSh0aGlzLl9zZW5kc210cChzdGFjaywgdGhpcy5fc2VuZG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7TWVzc2FnZVN0YWNrfSBzdGFjayBzdGFja1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIF9zZW5kbWVzc2FnZShzdGFjaykge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBzdGFjay5tZXNzYWdlLnN0cmVhbSgpO1xuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4gdGhpcy5zbXRwLm1lc3NhZ2UoZGF0YSkpO1xuICAgICAgICBzdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc210cC5kYXRhX2VuZCh0aGlzLl9zZW5kc210cChzdGFjaywgKCkgPT4gdGhpcy5fc2VuZGRvbmUobnVsbCwgc3RhY2spKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2FuY2VsIGEgbWVzc2FnZSB3aGlsZSBpbiB0aGUgREFUQSBwb3J0aW9uLFxuICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIGNsb3NlIHRoZSBzb2NrZXQgdG8gcHJldmVudCBhIGJhZCBlbWFpbCBmcm9tIGdvaW5nIG91dFxuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zbXRwLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kZG9uZShlcnIsIHN0YWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgZXJyXG4gICAgICogQHBhcmFtIHtNZXNzYWdlU3RhY2t9IHN0YWNrIHN0YWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX3NlbmRkb25lKGVyciwgc3RhY2spIHtcbiAgICAgICAgdGhpcy5zZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YWNrLmNhbGxiYWNrKGVyciwgc3RhY2subWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX3BvbGwoKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFVVEhfTUVUSE9EUywgQlVGRkVSU0laRSwgREVGQVVMVF9USU1FT1VULCBNSU1FNjRDSFVOSywgTUlNRUNIVU5LLCBNZXNzYWdlLCBTTVRQQ2xpZW50LCBTTVRQQ29ubmVjdGlvbiwgU01UUEVycm9yLCBTTVRQRXJyb3JTdGF0ZXMsIFNNVFBSZXNwb25zZU1vbml0b3IsIFNNVFBTdGF0ZSwgYWRkcmVzc3BhcnNlciwgZ2V0UkZDMjgyMkRhdGUsIGdldFJGQzI4MjJEYXRlVVRDLCBpc1JGQzI4MjJEYXRlLCBtaW1lRW5jb2RlLCBtaW1lV29yZEVuY29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1haWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/emailjs/email.js\n");

/***/ })

};
;